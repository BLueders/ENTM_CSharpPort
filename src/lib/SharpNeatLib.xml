<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SharpNeatLib</name>
    </assembly>
    <members>
        <member name="T:SharpNeat.Utility.Utilities">
            <summary>
            General purpose static utility methods.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.Utilities.Shuffle``1(System.Collections.Generic.IList{``0},SharpNeat.Utility.FastRandom)">
            <summary>
            Randomly shuffles items within a list.
            </summary>
            <param name="list">The list to shuffle.</param>
            <param name="rng">Random number generator.</param>
        </member>
        <member name="M:SharpNeat.Utility.Utilities.ProbabilisticRound(System.Double,SharpNeat.Utility.FastRandom)">
            <summary>
            Rounds up or down to a whole number by using the fractional part of the input value
            as the probability that the value will be rounded up.
            
            This is useful if we wish to round values and then sum them without generating a rounding bias.
            For monetary rounding this problem is solved with rounding to e.g. the nearest even number which
            then causes a bias towards even numbers.
            
            This solution is more appropriate for certain types of scientific values.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.Utilities.CalculateMedian(System.Collections.Generic.IList{System.Double})">
            <summary>
            Calculates the median value in a list of sorted values.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.Utilities.IsSorted(System.Collections.Generic.IList{System.Double})">
            <summary>
            Indicates if a list of doubles is sorted into ascending order.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.Utilities.CalculateDistribution(System.Double[],System.Int32)">
            <summary>
            Calculate a frequency distribution for the provided array of values.
            1) The minimum and maximum values are found.
            2) The resulting value range is divided into equal sized sub-ranges (categoryCount).
            3) The number of values that fall into each category is determined.
            </summary>
        </member>
        <member name="T:SharpNeat.Utility.UInt32IdGenerator">
            <summary>
            Conveniently encapsulates a single UInt32, which is incremented to produce new IDs.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.UInt32IdGenerator.#ctor">
            <summary>
            Construct, setting the initial ID to zero.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.UInt32IdGenerator.#ctor(System.UInt32)">
            <summary>
            Construct, setting the initial ID to the value provided.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.UInt32IdGenerator.Reset">
            <summary>
            Resets the next ID back to zero.
            </summary>
        </member>
        <member name="P:SharpNeat.Utility.UInt32IdGenerator.NextId">
            <summary>
            Gets the next ID. IDs wrap around to zero when uint.MaxValue is reached. 
            </summary>
        </member>
        <member name="T:SharpNeat.SpeciationStrategies.KMeansClusteringStrategy`1">
            <summary>
            An ISpeciationStrategy that speciates genomes using the k-means clustering method.
            k-means requires a distance metric and as such this class requires am IDistanceMetric to be provided at 
            construction time. Different distance metrics can be used including NeatDistanceMetric which is 
            equivalent to the metric used in the standard NEAT method albeit with a different clustering/speciation
            algorithm (Standard NEAT does not use k-means).
            </summary>
            <typeparam name="TGenome">The genome2 type to apply clustering to.</typeparam>
        </member>
        <member name="T:SharpNeat.Core.ISpeciationStrategy`1">
            <summary>
            Represents a strategy for dividing genomes into distinct species.
            
            Speciation in NEAT is the process of dividing genomes in the population into distinct sub-populations (species)
            based on genome2 similarity, that is, we want similar genomes to be in the same specie so that they form a 
            gene pool that is more likely to produce fit offspring. This type of speciation is very much like the concept
            of clustering as used in the fields of computer science and data mining. This interface allows us to abstract
            the implementation of the speciation/clustering algorithm away from the main NEAT algorithm.
            
            Each cluster/specie is assigned an ID that is in turn assigned to the genomes in the cluster. In addition each 
            instance of the Specie class contains a list of all genomes within that specie.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.ISpeciationStrategy`1.InitializeSpeciation(System.Collections.Generic.IList{`0},System.Int32)">
            <summary>
            Speciates the genomes in genomeList into the number of species specified by specieCount
            and returns a newly constructed list of Specie objects containing the speciated genomes.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.ISpeciationStrategy`1.SpeciateGenomes(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{SharpNeat.Core.Specie{`0}})">
            <summary>
            Speciates the genomes in genomeList into the provided species. It is assumed that
            the genomeList represents all of the required genomes and that the species are currently empty.
            
            This method can be used for initialization or completely respeciating an existing genome2 population.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.ISpeciationStrategy`1.SpeciateOffspring(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{SharpNeat.Core.Specie{`0}})">
            <summary>
            Speciates the offspring genomes in genomeList into the provided species. In contrast to
            SpeciateGenomes() genomeList is taken to be a list of new genomes (e.g. offspring) that should be 
            added to existing species. That is, the specieList contain genomes that are not in genomeList
            that we wish to keep; typically these would be elite genomes that are the parents of the
            offspring.
            </summary>
        </member>
        <member name="M:SharpNeat.SpeciationStrategies.KMeansClusteringStrategy`1.#ctor(SharpNeat.Core.IDistanceMetric)">
            <summary>
            Constructor that accepts an IDistanceMetric to be used for the k-means method.
            </summary>
        </member>
        <member name="M:SharpNeat.SpeciationStrategies.KMeansClusteringStrategy`1.InitializeSpeciation(System.Collections.Generic.IList{`0},System.Int32)">
            <summary>
            Speciates the genomes in genomeList into the number of species specified by specieCount
            and returns a newly constructed list of Specie objects containing the speciated genomes.
            </summary>
        </member>
        <member name="M:SharpNeat.SpeciationStrategies.KMeansClusteringStrategy`1.SpeciateGenomes(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{SharpNeat.Core.Specie{`0}})">
            <summary>
            Speciates the genomes in genomeList into the provided specieList. It is assumed that
            the genomeList represents all of the required genomes and that the species are currently empty.
            
            This method can be used for initialization or completely respeciating an existing genome2 population.
            </summary>
        </member>
        <member name="M:SharpNeat.SpeciationStrategies.KMeansClusteringStrategy`1.SpeciateOffspring(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{SharpNeat.Core.Specie{`0}})">
            <summary>
            Speciates the offspring genomes in offspringList into the provided specieList. In contrast to
            SpeciateGenomes() offspringList is taken to be a list of new genomes (offspring) that should be 
            added to existing species. That is, the species contain genomes that are not in offspringList
            that we wish to keep; typically these would be elite genomes that are the parents of the
            offspring.
            </summary>
        </member>
        <member name="M:SharpNeat.SpeciationStrategies.KMeansClusteringStrategy`1.SpeciateUntilConvergence(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{SharpNeat.Core.Specie{`0}})">
            <summary>
            Perform the main k-means loop until no genome2 reallocations occur or some maximum number of loops
            has been performed. Theoretically a small number of reallocations may occur for a great many loops 
            therefore we require the additional max loops threshold exit strategy - the clusters should be pretty
            stable and well defined after a few loops even if the the algorithm hasn't converged completely.
            </summary>
        </member>
        <member name="M:SharpNeat.SpeciationStrategies.KMeansClusteringStrategy`1.CalculateSpecieCentroid(SharpNeat.Core.Specie{`0})">
            <summary>
            Recalculate the specie centroid based on the genomes currently in the specie.
            </summary>
        </member>
        <member name="M:SharpNeat.SpeciationStrategies.KMeansClusteringStrategy`1.GetGenomesByDistanceFromSpecie(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{SharpNeat.Core.Specie{`0}})">
            <summary>
            Gets an array of all genomes ordered by their distance from their current specie.
            </summary>
        </member>
        <member name="M:SharpNeat.SpeciationStrategies.KMeansClusteringStrategy`1.FindClosestSpecie(`0,System.Collections.Generic.IList{SharpNeat.Core.Specie{`0}})">
            <summary>
            Find the specie that a genome2 is closest to as determined by the distance metric.
            </summary>
        </member>
        <member name="T:SharpNeat.Network.SteepenedSigmoidApproximation">
            <summary>
            An approximation of the SteepenedSigmoid activation function. Faster to calculate but anecdotal evidence
            suggests using this function gives poorer results than SteepenedSigmoid.
            
            The increase in speed may also be in question with more recent hardware developments. E.g. with faster
            implementations of an exp function and underlying CPU execution of the code.
            </summary>
        </member>
        <member name="T:SharpNeat.Network.IActivationFunction">
            <summary>
            Interface for neural network activation functions. An activation function simply takes a single input 
            value and produces a single output value. IActivationFunction allows for activation functions to be 
            plugged in to neural network implementations. Typical activation functions would be a sigmoid or step 
            function.
            
            The Calculate method has two overloads, one for each of the data types double and float, this allows
            an IActivationFunction object to be plugged in to neural network classes that are written to operate
            with either of those two data types. Typically the choice of which neural network implementation and
            floating point precision to use is part of the setting up and design of a problem domain and experiment.
            For some problem domains the extra precision of a double may be unnecessary.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.IActivationFunction.Calculate(System.Double)">
            <summary>
            Calculates the output value for the specified input value.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.IActivationFunction.Calculate(System.Single)">
            <summary>
            Calculates the output value for the specified input value with float/single precision.
            This single precision overload of Calculate() will be used in neural network code 
            that has been specifically written to use floats instead of doubles.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.IActivationFunction.FunctionId">
            <summary>
            Gets the unique ID of the function. Stored in network XML to identify which function a network or neuron 
            is using.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.IActivationFunction.FunctionString">
            <summary>
            Gets a human readable string representation of the function. E.g 'y=1/x'.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.IActivationFunction.FunctionDescription">
            <summary>
            Gets a human readable verbose description of the activation function.
            </summary>
        </member>
        <member name="F:SharpNeat.Network.SteepenedSigmoidApproximation.__DefaultInstance">
            <summary>
            Default instance provided as a public static field.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.SteepenedSigmoidApproximation.Calculate(System.Double)">
            <summary>
            Calculates the output value for the specified input value.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.SteepenedSigmoidApproximation.Calculate(System.Single)">
            <summary>
            Calculates the output value for the specified input value with float/single precision.
            This single precision overload of Calculate() will be used in neural network code 
            that has been specifically written to use floats instead of doubles.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.SteepenedSigmoidApproximation.FunctionId">
            <summary>
            Gets the unique ID of the function. Stored in network XML to identify which function a network or neuron 
            is using.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.SteepenedSigmoidApproximation.FunctionString">
            <summary>
            Gets a human readable string representation of the function. E.g 'y=1/x'.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.SteepenedSigmoidApproximation.FunctionDescription">
            <summary>
            Gets a human readable verbose description of the activation function.
            </summary>
        </member>
        <member name="T:SharpNeat.Network.IConnectionList">
            <summary>
            Represents a list of INetworkConnection's.
            Part of the INetworkDefinition type hierarchy.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.IConnectionList.Item(System.Int32)">
            <summary>
            Gets the INetworkConnection at the specified index.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.IConnectionList.Count">
            <summary>
            Gets the count of connections in the list.
            </summary>
        </member>
        <member name="T:SharpNeat.Decoders.HyperNeat.INodeSetMappingFunction">
            <summary>
            Implementations of INodeSetMappingFunction define a mapping between source and target node sets. 
            Each mapping is interpreted/used as a connection between the source and target node.
            E.g. the simplest such function is to map every source node to every target node (N*M connections).
            </summary>
        </member>
        <member name="M:SharpNeat.Decoders.HyperNeat.INodeSetMappingFunction.GenerateConnections(SharpNeat.Decoders.HyperNeat.SubstrateNodeSet,SharpNeat.Decoders.HyperNeat.SubstrateNodeSet)">
            <summary>
            Returns an IEnumerable that yields the mappings/connections defined by the mapping function (from the source nodes to
            the target nodes) as a sequence. The alternative of returning a list would require a very long list in extreme scenarios; 
            this approach minimizes down memory usage.
            </summary>
        </member>
        <member name="M:SharpNeat.Decoders.HyperNeat.INodeSetMappingFunction.GetConnectionCountHint(SharpNeat.Decoders.HyperNeat.SubstrateNodeSet,SharpNeat.Decoders.HyperNeat.SubstrateNodeSet)">
            <summary>
            Returns an estimate/hint for the number of connections that would be created between the provided source and target node sets.
            </summary>
        </member>
        <member name="T:SharpNeat.Phenomes.NeuralNets.RecurrentNetwork">
            <summary>
            This class is provided for debugging and educational purposes. FastRecurrentNetwork is functionally
            equivalent and is much faster and therefore should be used instead of RecurrentNetwork in most 
            circumstances.
            
            A neural network class that represents a network with recurrent (cyclic) connections. Recurrent
            connections are handled by each neuron storing two values, a pre- and post-activation value 
            (InputValue and OutputValue). This allows us to calculate the output value for the current 
            iteration/timestep without modifying the output values from the previous iteration. That is, we
            calculate all of this timestep's state based on state from the previous timestep.
            
            When activating networks of this class the network's state is updated for a fixed number of 
            timesteps, the number of which is specified by the maxIterations parameter on the constructor.
            See RelaxingRecurrentNetwork for an alternative activation scheme.
            </summary>
        </member>
        <member name="T:SharpNeat.Phenomes.IBlackBox">
            <summary>
            IBlackBox represents an abstract device, system or function which has inputs and outputs. The internal
            workings and state of the box are not relevant to any method or class that acceps an IBlackBox - only that it
            has inputs and outputs and a means of activation. In NEAT the neural network implementations generally fit this
            pattern, that is:
            
             - inputs are fed to a network.
             - The network is actvated (e.g. some fixed number of timesteps or to relaxation).
             - The network outputs are read and fed into the evaluation/scoring/fitness scheme.
            
            From wikipedia:
            Black box is a technical term for a device or system or object when it is viewed primarily in terms 
            of its input and output characteristics. Almost anything might occasionally be referred to as a black box -
            a transistor, an algorithm, humans, the Internet.
            </summary>
        </member>
        <member name="M:SharpNeat.Phenomes.IBlackBox.Activate">
            <summary>
            Activate the black box. This is a request for the box to accept its inputs and produce output signals
            ready for reading from OutputSignalArray.
            </summary>
        </member>
        <member name="M:SharpNeat.Phenomes.IBlackBox.ResetState">
            <summary>
            Reset any internal state.
            </summary>
        </member>
        <member name="P:SharpNeat.Phenomes.IBlackBox.InputCount">
            <summary>
            Gets the number of inputs to the blackbox. This is assumed to be fixed for the lifetime of the IBlackBox.
            </summary>
        </member>
        <member name="P:SharpNeat.Phenomes.IBlackBox.OutputCount">
            <summary>
            Gets the number of outputs from the blackbox. This is assumed to be fixed for the lifetime of the IBlackBox.
            </summary>
        </member>
        <member name="P:SharpNeat.Phenomes.IBlackBox.InputSignalArray">
            <summary>
            Gets an array of input values that feed into the black box. 
            </summary>
        </member>
        <member name="P:SharpNeat.Phenomes.IBlackBox.OutputSignalArray">
            <summary>
            Gets an array of output values that feed out from the black box. 
            </summary>
        </member>
        <member name="P:SharpNeat.Phenomes.IBlackBox.IsStateValid">
            <summary>
            Gets a value indicating whether the black box's internal state is valid. It may become invalid if e.g. we ask a recurrent
            neural network to relax and it is unable to do so.
            </summary>
        </member>
        <member name="M:SharpNeat.Phenomes.NeuralNets.RecurrentNetwork.#ctor(System.Collections.Generic.List{SharpNeat.Phenomes.NeuralNets.Neuron},System.Collections.Generic.List{SharpNeat.Phenomes.NeuralNets.Connection},System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs a RecurrentNetwork with the provided pre-built neurons and connections.
            </summary>
        </member>
        <member name="M:SharpNeat.Phenomes.NeuralNets.RecurrentNetwork.Activate">
            <summary>
            Activate the network for a fixed number of timesteps defined by maxTimesteps is reached.
            </summary>
        </member>
        <member name="M:SharpNeat.Phenomes.NeuralNets.RecurrentNetwork.ResetState">
            <summary>
            Reset the network's internal state.
            </summary>
        </member>
        <member name="P:SharpNeat.Phenomes.NeuralNets.RecurrentNetwork.InputCount">
            <summary>
            Gets the number of inputs.
            </summary>
        </member>
        <member name="P:SharpNeat.Phenomes.NeuralNets.RecurrentNetwork.OutputCount">
            <summary>
            Gets the number of outputs.
            </summary>
        </member>
        <member name="P:SharpNeat.Phenomes.NeuralNets.RecurrentNetwork.InputSignalArray">
            <summary>
            Gets an array for feeding input signals to the network.
            </summary>
        </member>
        <member name="P:SharpNeat.Phenomes.NeuralNets.RecurrentNetwork.OutputSignalArray">
            <summary>
            Gets an array of output signals from the network.
            </summary>
        </member>
        <member name="P:SharpNeat.Phenomes.NeuralNets.RecurrentNetwork.IsStateValid">
            <summary>
            Gets a value indicating whether the internal state is valid. Always returns true for this class.
            </summary>
        </member>
        <member name="T:SharpNeat.Network.Sine">
            <summary>
            Sine activation function with doubled period.
            </summary>
        </member>
        <member name="F:SharpNeat.Network.Sine.__DefaultInstance">
            <summary>
            Default instance provided as a public static field.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.Sine.Calculate(System.Double)">
            <summary>
            Calculates the output value for the specified input value.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.Sine.Calculate(System.Single)">
            <summary>
            Calculates the output value for the specified input value with float/single precision.
            This single precision overload of Calculate() will be used in neural network code 
            that has been specifically written to use floats instead of doubles.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.Sine.FunctionId">
            <summary>
            Gets the unique ID of the function. Stored in network XML to identify which function a network or neuron 
            is using.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.Sine.FunctionString">
            <summary>
            Gets a human readable string representation of the function. E.g 'y=1/x'.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.Sine.FunctionDescription">
            <summary>
            Gets a human readable verbose description of the activation function.
            </summary>
        </member>
        <member name="T:SharpNeat.Network.INodeList">
            <summary>
            Represents a list of INetworkNode's.
            Part of the INetworkDefinition type hierarchy.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.INodeList.BinarySearch(System.UInt32)">
            <summary>
            Gets the index of the INetworkNode with the specified ID. 
            Uses a binary search for fast searching, however this assumes the nodes are sorted by
            ID in ascending order.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.INodeList.IsSorted">
            <summary>
            Indicates if the nodes are sorted by ID in ascending order, as required by BinarySearch().
            For debug purposes only. Don't call this method in normal circumstances as it is an
            expensive O(n) operation.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.INodeList.Item(System.Int32)">
            <summary>
            Gets the INetworkNode at the specified index.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.INodeList.Count">
            <summary>
            Gets the count of nodes in the list.
            </summary>
        </member>
        <member name="T:SharpNeat.Genomes.Neat.CorrelationStatistics">
            <summary>
            Statistics resulting from the comparison of two NEAT genomes.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.CorrelationStatistics.MatchingGeneCount">
            <summary>
            Gets or sets the number of matching connection genes between the two comparison genomes.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.CorrelationStatistics.DisjointConnectionGeneCount">
            <summary>
            Gets or sets the number of disjoint connection genes between the two comparison genomes.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.CorrelationStatistics.ExcessConnectionGeneCount">
            <summary>
            Gets or sets the number of excess connection genes between the two comparison genomes.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.CorrelationStatistics.ConnectionWeightDelta">
            <summary>
            Gets or sets the cumulative total of absolute weight differences between all of the connection genes that matched up.
            </summary>
        </member>
        <member name="T:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithm`1">
            <summary>
            Implementation of the NEAT evolution algorithm. 
            Incorporates:
                - Speciation with fitness sharing.
                - Creating offspring via both sexual and asexual reproduction.
            </summary>
            <typeparam name="TGenome">The genome2 type that the algorithm will operate on.</typeparam>
        </member>
        <member name="T:SharpNeat.EvolutionAlgorithms.AbstractGenerationalAlgorithm`1">
            <summary>
            Abstract class providing some common/baseline data and methods for implementions of IEvolutionAlgorithm.
            </summary>
            <typeparam name="TGenome">The genome2 type that the algorithm will operate on.</typeparam>
        </member>
        <member name="T:SharpNeat.Core.IEvolutionAlgorithm`1">
            <summary>
            A generic interface for evolution algorithm classes.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.IEvolutionAlgorithm`1.Initialize(SharpNeat.Core.IGenomeListEvaluator{`0},SharpNeat.Core.IGenomeFactory{`0},System.Collections.Generic.List{`0})">
            <summary>
            Initializes the evolution algorithm with the provided IGenomeListEvaluator, IGenomeFactory
            and an initial population of genomes.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.IEvolutionAlgorithm`1.Initialize(SharpNeat.Core.IGenomeListEvaluator{`0},SharpNeat.Core.IGenomeFactory{`0},System.Int32)">
            <summary>
            Initializes the evolution algorithm with the provided IGenomeListEvaluator
            and an IGenomeFactory that can be used to create an initial population of genomes.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.IEvolutionAlgorithm`1.StartContinue">
            <summary>
            Starts the algorithm running. The algorithm will switch to the Running state from either
            the Ready or Paused states.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.IEvolutionAlgorithm`1.RequestPause">
            <summary>
            Requests that the algorithm pauses but doesn't wait for the algorithm thread to stop.
            The algorithm thread will pause when it is next convenient to do so, and notifies
            listeners via an UpdateEvent.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.IEvolutionAlgorithm`1.RequestPauseAndWait">
            <summary>
            Request that the algorithm pause and waits for the algorithm to do so. The algorithm
            thread will pause when it is next convenient to do so and notifies any UpdateEvent 
            listeners prior to returning control to the caller. Therefore it's generally a bad idea 
            to call this method from a GUI thread that also has code that may be called by the
            UpdateEvent - doing so will result in deadlocked threads.
            </summary>
        </member>
        <member name="E:SharpNeat.Core.IEvolutionAlgorithm`1.UpdateEvent">
            <summary>
            Notifies listeners that some state change has occured.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.IEvolutionAlgorithm`1.UpdateScheme">
            <summary>
            Gets or sets the algorithm's update scheme.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.IEvolutionAlgorithm`1.RunState">
            <summary>
            Gets the current execution/run state of the IEvolutionAlgorithm.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.IEvolutionAlgorithm`1.CurrentChampGenome">
            <summary>
            Gets the population's current champion genome2.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.IEvolutionAlgorithm`1.StopConditionSatisfied">
            <summary>
            Gets a value indicating whether some goal fitness has been achieved and that the algorithm has therefore stopped.
            </summary>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithms.AbstractGenerationalAlgorithm`1.Initialize(SharpNeat.Core.IGenomeListEvaluator{`0},SharpNeat.Core.IGenomeFactory{`0},System.Collections.Generic.List{`0})">
            <summary>
            Initializes the evolution algorithm with the provided IGenomeListEvaluator, IGenomeFactory
            and an initial population of genomes.
            </summary>
            <param name="genomeListEvaluator">The genome2 evaluation scheme for the evolution algorithm.</param>
            <param name="genomeFactory">The factory that was used to create the genomeList and which is therefore referenced by the genomes.</param>
            <param name="genomeList">An initial genome2 population.</param>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithms.AbstractGenerationalAlgorithm`1.Initialize(SharpNeat.Core.IGenomeListEvaluator{`0},SharpNeat.Core.IGenomeFactory{`0},System.Int32)">
            <summary>
            Initializes the evolution algorithm with the provided IGenomeListEvaluator
            and an IGenomeFactory that can be used to create an initial population of genomes.
            </summary>
            <param name="genomeListEvaluator">The genome2 evaluation scheme for the evolution algorithm.</param>
            <param name="genomeFactory">The factory that was used to create the genomeList and which is therefore referenced by the genomes.</param>
            <param name="populationSize">The number of genomes to create for the initial population.</param>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithms.AbstractGenerationalAlgorithm`1.StartContinue">
            <summary>
            Starts the algorithm running. The algorithm will switch to the Running state from either
            the Ready or Paused states.
            </summary>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithms.AbstractGenerationalAlgorithm`1.Stop">
            <summary>
            Alias for RequestPause().
            </summary>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithms.AbstractGenerationalAlgorithm`1.RequestPause">
            <summary>
            Requests that the algorithm pauses but doesn't wait for the algorithm thread to stop.
            The algorithm thread will pause when it is next convenient to do so, and will notify
            listeners via an UpdateEvent.
            </summary>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithms.AbstractGenerationalAlgorithm`1.RequestPauseAndWait">
            <summary>
            Request that the algorithm pause and waits for the algorithm to do so. The algorithm
            thread will pause when it is next convenient to do so and notifies any UpdateEvent 
            listeners prior to returning control to the caller. Therefore it's generally a bad idea 
            to call this method from a GUI thread that also has code that may be called by the
            UpdateEvent - doing so will result in deadlocked threads.
            </summary>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithms.AbstractGenerationalAlgorithm`1.UpdateTest">
            <summary>
            Returns true if it is time to raise an update event.
            </summary>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithms.AbstractGenerationalAlgorithm`1.PerformOneGeneration">
            <summary>
            Progress forward by one generation. Perform one generation/cycle of the evolution algorithm.
            </summary>
        </member>
        <member name="E:SharpNeat.EvolutionAlgorithms.AbstractGenerationalAlgorithm`1.UpdateEvent">
            <summary>
            Notifies listeners that some state change has occured.
            </summary>
        </member>
        <member name="E:SharpNeat.EvolutionAlgorithms.AbstractGenerationalAlgorithm`1.PausedEvent">
            <summary>
            Notifies listeners that the algorithm has paused.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithms.AbstractGenerationalAlgorithm`1.CurrentGeneration">
            <summary>
            Gets the current generation.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithms.AbstractGenerationalAlgorithm`1.UpdateScheme">
            <summary>
            Gets or sets the algorithm's update scheme.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithms.AbstractGenerationalAlgorithm`1.RunState">
            <summary>
            Gets the current execution/run state of the IEvolutionAlgorithm.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithms.AbstractGenerationalAlgorithm`1.CurrentChampGenome">
            <summary>
            Gets the population's current champion genome2.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithms.AbstractGenerationalAlgorithm`1.StopConditionSatisfied">
            <summary>
            Gets a value indicating whether some goal fitness has been achieved and that the algorithm has therefore stopped.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithm`1._bestSpecieIdx">
            <summary>Index of the specie that contains _currentBestGenome.</summary>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithm`1.#ctor">
            <summary>
            Constructs with the default NeatEvolutionAlgorithmParameters and speciation strategy 
            (KMeansClusteringStrategy with ManhattanDistanceMetric).
            </summary>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithm`1.#ctor(SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithmParameters,SharpNeat.Core.ISpeciationStrategy{`0},SharpNeat.EvolutionAlgorithms.ComplexityRegulation.IComplexityRegulationStrategy)">
            <summary>
            Constructs with the provided NeatEvolutionAlgorithmParameters and ISpeciationStrategy.
            </summary>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithm`1.Initialize(SharpNeat.Core.IGenomeListEvaluator{`0},SharpNeat.Core.IGenomeFactory{`0},System.Collections.Generic.List{`0})">
            <summary>
            Initializes the evolution algorithm with the provided IGenomeListEvaluator, IGenomeFactory
            and an initial population of genomes.
            </summary>
            <param name="genomeListEvaluator">The genome2 evaluation scheme for the evolution algorithm.</param>
            <param name="genomeFactory">The factory that was used to create the genomeList and which is therefore referenced by the genomes.</param>
            <param name="genomeList">An initial genome2 population.</param>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithm`1.Initialize(SharpNeat.Core.IGenomeListEvaluator{`0},SharpNeat.Core.IGenomeFactory{`0},System.Int32)">
            <summary>
            Initializes the evolution algorithm with the provided IGenomeListEvaluator
            and an IGenomeFactory that can be used to create an initial population of genomes.
            </summary>
            <param name="genomeListEvaluator">The genome2 evaluation scheme for the evolution algorithm.</param>
            <param name="genomeFactory">The factory that was used to create the genomeList and which is therefore referenced by the genomes.</param>
            <param name="populationSize">The number of genomes to create for the initial population.</param>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithm`1.Initialize">
            <summary>
            Code common to both public Initialize methods.
            </summary>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithm`1.PerformOneGeneration">
            <summary>
            Progress forward by one generation. Perform one generation/iteration of the evolution algorithm.
            </summary>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithm`1.CalcSpecieStats(System.Int32@)">
            <summary>
            Calculate statistics for each specie. This method is at the heart of the evolutionary algorithm,
            the key things that are achieved in this method are - for each specie we calculate:
             1) The target size based on fitness of the specie's member genomes.
             2) The elite size based on the current size. Potentially this could be higher than the target 
                size, so a target size is taken to be a hard limit.
             3) Following (1) and (2) we can calculate the total number offspring that need to be generated 
                for the current generation.
            </summary>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithm`1.CreateOffspring(SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithm{`0}.SpecieStats[],System.Int32)">
            <summary>
            Create the required number of offspring genomes, using specieStatsArr as the basis for selecting how
            many offspring are produced from each species.
            </summary>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithm`1.CreateOffspring_CrossSpecieMating(SharpNeat.Utility.RouletteWheelLayout,SharpNeat.Utility.RouletteWheelLayout[],SharpNeat.Utility.RouletteWheelLayout,System.Int32,System.Collections.Generic.IList{`0})">
            <summary>
            Cross specie mating.
            </summary>
            <param name="rwl">RouletteWheelLayout for selectign genomes in teh current specie.</param>
            <param name="rwlArr">Array of RouletteWheelLayout objects for genome2 selection. One for each specie.</param>
            <param name="rwlSpecies">RouletteWheelLayout for selecting species. Based on relative fitness of species.</param>
            <param name="currentSpecieIdx">Current specie's index in _specieList</param>
            <param name="genomeList">Current specie's genome2 list.</param>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithm`1.UpdateBestGenome">
            <summary>
            Updates _currentBestGenome and _bestSpecieIdx, these are the fittest genome2 and index of the specie
            containing the fittest genome2 respectively.
            
            This method assumes that all specie genomes are sorted fittest first and can therefore save much work
            by not having to scan all genomes.
            Note. We may have several genomes with equal best fitness, we just select one of them in that case.
            </summary>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithm`1.UpdateStats">
            <summary>
            Updates the NeatAlgorithmStats object.
            </summary>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithm`1.SortSpecieGenomes">
            <summary>
            Sorts the genomes within each species fittest first, secondary sorts on age.
            </summary>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithm`1.ClearAllSpecies">
            <summary>
            Clear the genome2 list within each specie.
            </summary>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithm`1.RebuildGenomeList">
            <summary>
            Rebuild _genomeList from genomes held within the species.
            </summary>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithm`1.TrimSpeciesBackToElite(SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithm{`0}.SpecieStats[])">
            <summary>
            Trims the genomeList in each specie back to the number of elite genomes specified in
            specieStatsArr. Returns true if there are empty species following trimming.
            </summary>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithm`1.TestForEmptySpecies(System.Collections.Generic.IList{SharpNeat.Core.Specie{`0}})">
            <summary>
            Returns true if there is one or more empty species.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithm`1.GenomeList">
            <summary>
            Gets a list of all current genomes. The current population of genomes. These genomes
            are also divided into the species available through the SpeciesList property.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithm`1.SpecieList">
            <summary>
            Gets a list of all current species. The genomes contained within the species are the same genomes
            available through the GenomeList property.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithm`1.Statistics">
            <summary>
            Gets the algorithm statistics object.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithm`1.ComplexityRegulationMode">
            <summary>
            Gets the current complexity regulation mode.
            </summary>
        </member>
        <member name="T:SharpNeat.Decoders.Neat.NeatGenomeDecoder">
            <summary>
            Decodes NeatGenome's into concrete network instances.
            </summary>
        </member>
        <member name="T:SharpNeat.Core.IGenomeDecoder`2">
            <summary>
            Generic interface for classes that decode genomes into phenomes.
            </summary>
            <typeparam name="TGenome">The genome2 type to be decoded.</typeparam>
            <typeparam name="TPhenome">The phenome type that is decoded to.</typeparam>
        </member>
        <member name="M:SharpNeat.Core.IGenomeDecoder`2.Decode(`0)">
            <summary>
            Decodes a genome2 into a phenome. Note that not all genomes have to decode successfully. That is, we 
            support genetic representations that may produce non-viable offspring. In such cases this method
            can return a null.
            </summary>
        </member>
        <member name="M:SharpNeat.Decoders.Neat.NeatGenomeDecoder.#ctor(SharpNeat.Decoders.NetworkActivationScheme)">
            <summary>
            Construct the decoder with the network activation scheme to use in decoded networks.
            </summary>
        </member>
        <member name="M:SharpNeat.Decoders.Neat.NeatGenomeDecoder.Decode(SharpNeat.Genomes.Neat.NeatGenome)">
            <summary>
            Decodes a NeatGenome to a concrete network instance.
            </summary>
        </member>
        <member name="T:SharpNeat.Core.IGenome`1">
            <summary>
            Generic interface for genome2 classes.
            
            Concrete IGenome classes are expected to to be given a reference to their concrete IGenomeFactory class even 
            if they are spawned from another IGenome. This allows all genomes to use the same set of parameters
            for spawning - which may change during evolution, e.g. in the case of phased searching in NEAT.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.IGenome`1.CreateOffspring(System.UInt32)">
            <summary>
            Asexual reproduction.
            </summary>
            <param name="birthGeneration">The current evolution algorithm generation. 
            Assigned to the new genome2 at its birth generation.</param>
        </member>
        <member name="M:SharpNeat.Core.IGenome`1.CreateOffspring(`0,System.UInt32)">
            <summary>
            Sexual reproduction.
            </summary>
            <param name="parent">The other parent genome2.</param>
            <param name="birthGeneration">The current evolution algorithm generation. 
            Assigned to the new genome2 at its birth generation.</param>
        </member>
        <member name="P:SharpNeat.Core.IGenome`1.Id">
            <summary>
            Gets the genome2's unique ID. IDs are unique across all genomes created from a single 
            IGenomeFactory.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.IGenome`1.SpecieIdx">
            <summary>
            Gets or sets a specie index. An implemention of this is required only when using 
            evolution algorithms that speciate genomes.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.IGenome`1.BirthGeneration">
            <summary>
            Gets the generation that this genome2 was born/created in. Used to track genome2 age.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.IGenome`1.EvaluationInfo">
            <summary>
            Gets the evaluation information for the genome2, including its fitness.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.IGenome`1.Complexity">
            <summary>
            Gets a value that indicates the magnitude of a genome2's complexity.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.IGenome`1.Position">
            <summary>
            Gets a coordinate that represents the genome2's position in the search space (also known
            as the genetic encoding space). This allows speciation/clustering algorithms to operate on
            an abstract cordinate data type rather than being coded against specific IGenome types.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.IGenome`1.CachedPhenome">
            <summary>
            Gets or sets a cached phenome obtained from decodign the genome2.
            Genomes are typically decoded to Phenomes for evaluation. This property allows decoders to 
            cache the phenome in order to avoid decoding on each re-evaluation; However, this is optional.
            The phenome in un-typed to prevent the class framework from becoming overly complex.
            </summary>
        </member>
        <member name="T:SharpNeat.Utility.ParallelSort">
            <summary>
            Parallel quicksort algorithm.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.ParallelSort.QuicksortSequential``1(``0[])">
            <summary>
            Sequential quicksort.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.ParallelSort.QuicksortParallel``1(``0[])">
            <summary>
            Parallel quicksort
            </summary>
        </member>
        <member name="T:SharpNeat.Utility.FrequencyDistributionData">
            <summary>
            Frequency distribution data from a distribution analysis of some data series.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.FrequencyDistributionData.#ctor(System.Double,System.Double,System.Double,System.Int32[])">
            <summary>
            Construct with the provided frequency distribution data.
            </summary>
            <param name="min">The minimum value in the data series the distribution represents.</param>
            <param name="max">The maximum value in the data series the distribution represents.</param>
            <param name="increment">The range of a single category bucket.</param>
            <param name="frequencyArr">The array of category frequency counts.</param>
        </member>
        <member name="P:SharpNeat.Utility.FrequencyDistributionData.Min">
            <summary>
            The minimum value in the data series the distribution represents.
            </summary>
        </member>
        <member name="P:SharpNeat.Utility.FrequencyDistributionData.Max">
            <summary>
            The maximum value in the data series the distribution represents.
            </summary>
        </member>
        <member name="P:SharpNeat.Utility.FrequencyDistributionData.Increment">
            <summary>
            The range of a single category bucket.
            </summary>
        </member>
        <member name="P:SharpNeat.Utility.FrequencyDistributionData.FrequencyArray">
            <summary>
            The array of category frequency counts.
            </summary>
        </member>
        <member name="T:SharpNeat.Genomes.Neat.CorrelationResults">
            <summary>
            The results from comparing two NEAT genomes and correlating their connection genes.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.CorrelationResults.#ctor(System.Int32)">
            <summary>
            Cosntructs with a specified initial correlation item list capacity.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.CorrelationResults.PerformIntegrityCheck">
            <summary>
            Performs an integrity check on the correlation items.
            Returns true if the test is passed.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.CorrelationResults.CorrelationStatistics">
            <summary>
            Gets the statistics for the genome2 comparison.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.CorrelationResults.CorrelationItemList">
            <summary>
            Gets the list of correlation items from the genome2 comparison.
            </summary>
        </member>
        <member name="T:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithmParameters">
            <summary>
            Parameters specific to the NEAT evolution algorithm.
            </summary>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithmParameters.#ctor">
            <summary>
            Constructs with the default parameters.
            </summary>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithmParameters.#ctor(SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithmParameters)">
            <summary>
            Copy constructor.
            </summary>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithmParameters.NormalizeProportions">
            <summary>
            Normalize the sexual and asexual proportions such that their sum equals 1.
            </summary>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithmParameters.CreateSimplifyingParameters">
            <summary>
            Creates a set of parameters based on the current set and that are suitable for the simplifying 
            phase of the evolution algorithm when running with complexity regulation enabled.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithmParameters.SpecieCount">
            <summary>
            Gets or sets the specie count.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithmParameters.ElitismProportion">
            <summary>
            Gets or sets the elitism proportion. 
            We sort specie genomes by fitness and keep the top N%, the other genomes are
            removed to make way for the offspring.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithmParameters.SelectionProportion">
            <summary>
            Gets or sets the selection proportion.
            We sort specie genomes by fitness and select parent genomes for producing offspring from 
            the top N%. Selection is performed prior to elitism being applied, therefore selecting from more
            genomes than will be made elite is possible.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithmParameters.OffspringAsexualProportion">
            <summary>
            Gets or sets the proportion of offspring to be produced from asexual reproduction (mutation).
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithmParameters.OffspringSexualProportion">
            <summary>
            Gets or sets the proportion of offspring to be produced from sexual reproduction.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithmParameters.InterspeciesMatingProportion">
            <summary>
            Gets or sets the proportion of sexual reproductions that will use genomes from different species.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithmParameters.BestFitnessMovingAverageHistoryLength">
            <summary>
            Gets or sets the history buffer length used for calculating the best fitness moving average.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithmParameters.MeanSpecieChampFitnessMovingAverageHistoryLength">
            <summary>
            Gets or sets the history buffer length used for calculating the mean specie champ fitness
            moving average.
            </summary>
        </member>
        <member name="P:SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithmParameters.ComplexityMovingAverageHistoryLength">
            <summary>
            Gets or sets the history buffer length used for calculating the mean genome2 complexity moving 
            average.
            </summary>
        </member>
        <member name="T:SharpNeat.Decoders.HyperNeat.HyperNeatDecoder">
            <summary>
            Decodes CPPN NeatGenome's into concrete network instances.
            This decoder uses a HyperNEAT substrate and queries a CPPN NEAT network to
            generate/grow a network from the substrate.
            </summary>
        </member>
        <member name="M:SharpNeat.Decoders.HyperNeat.HyperNeatDecoder.#ctor(SharpNeat.Decoders.HyperNeat.Substrate,SharpNeat.Decoders.NetworkActivationScheme,SharpNeat.Decoders.NetworkActivationScheme)">
            <summary>
            Constructs with the provided substrate, CPPN activation scheme and substrate 
            network activation scheme.
            </summary>
        </member>
        <member name="M:SharpNeat.Decoders.HyperNeat.HyperNeatDecoder.#ctor(SharpNeat.Decoders.HyperNeat.Substrate,SharpNeat.Decoders.NetworkActivationScheme,SharpNeat.Decoders.NetworkActivationScheme,System.Boolean)">
            <summary>
            Constructs with the provided substrate, CPPN activation scheme and substrate 
            network activation scheme.
            </summary>
        </member>
        <member name="M:SharpNeat.Decoders.HyperNeat.HyperNeatDecoder.Decode(SharpNeat.Genomes.Neat.NeatGenome)">
            <summary>
            Decodes a CPPN NeatGenome to a concrete network instance via a HyperNEAT substrate.
            </summary>
        </member>
        <member name="M:SharpNeat.Decoders.HyperNeat.HyperNeatDecoder.GetDecodeCppnMethod(SharpNeat.Decoders.NetworkActivationScheme)">
            <summary>
            Method that determines which CPPN decode routine to use.
            </summary>
        </member>
        <member name="M:SharpNeat.Decoders.HyperNeat.HyperNeatDecoder.GetCreateSubstrateNetworkMethod(SharpNeat.Decoders.NetworkActivationScheme)">
            <summary>
            Method that determines which substrate instance creation routine to use.
            </summary>
        </member>
        <member name="T:SharpNeat.Core.IPhenomeEvaluator`1">
            <summary>
            Generic interface for phenome evaluation classes.
            Evaluates and assigns a fitness to individual TPhenome's.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.IPhenomeEvaluator`1.Evaluate(`0)">
            <summary>
            Evaluate the provided phenome and return its fitness score.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.IPhenomeEvaluator`1.Reset">
            <summary>
            Reset the internal state of the evaluation scheme if any exists.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.IPhenomeEvaluator`1.EvaluationCount">
            <summary>
            Gets the total number of individual genome2 evaluations that have been performed by this evaluator.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.IPhenomeEvaluator`1.StopConditionSatisfied">
            <summary>
            Gets a value indicating whether some goal fitness has been achieved and that
            the the evolutionary algorithm search should stop. This property's value can remain false
            to allow the algorithm to run indefinitely.
            </summary>
        </member>
        <member name="T:SharpNeat.Utility.CircularBuffer`1">
            <summary>
            This is a generic circular buffer of items of type T.  A circular buffer must be assigned
            a capacity at construction time. Items can be enqueued indefintely, but when the buffer's 
            capacity is reached the oldest values in the buffer are overwritten, thus the buffer is best
            thought of as a circular array or buffer.
            </summary>
        </member>
        <member name="F:SharpNeat.Utility.CircularBuffer`1._buff">
            <summary>
            Internal array that stores the circular buffer's values.
            </summary>
        </member>
        <member name="F:SharpNeat.Utility.CircularBuffer`1._headIdx">
            <summary>
            The index of the previously enqueued item. -1 if buffer is empty.
            </summary>
        </member>
        <member name="F:SharpNeat.Utility.CircularBuffer`1._tailIdx">
            <summary>
            The index of the next item to be dequeued. -1 if buffer is empty.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.CircularBuffer`1.#ctor(System.Int32)">
            <summary>
            Constructs a circular buffer with the specified capacity.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.CircularBuffer`1.Clear">
            <summary>
            Clear the buffer.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.CircularBuffer`1.Enqueue(`0)">
            <summary>
            Enqueue a new item. This overwrites the oldest item in the buffer if the buffer
            has reached capacity.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.CircularBuffer`1.Dequeue">
            <summary>
            Remove the oldest item from the back end of the buffer and return it.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.CircularBuffer`1.Pop">
            <summary>
            Pop the most recently added item from the front end of the buffer and return it.
            </summary>
        </member>
        <member name="P:SharpNeat.Utility.CircularBuffer`1.Length">
            <summary>
            Gets the number of items in the buffer. Returns the buffer's capacity
            if it is full.
            </summary>
        </member>
        <member name="P:SharpNeat.Utility.CircularBuffer`1.Item(System.Int32)">
            <summary>
            Gets or sets an item at the specified index. The setter can only be used to replace an existing item, it
            cannot insert a new item at an arbitrary index.
            </summary>
        </member>
        <member name="T:SharpNeat.Genomes.Neat.CorrelationItemType">
            <summary>
            An enumeration of connection gene correlation types.
            Mismatched genes can be disjoint or excess. This distinction is defined by original
            NEAT but is probably redundant for most genome2 comparison/distance metrics.
            </summary>
        </member>
        <member name="F:SharpNeat.Genomes.Neat.CorrelationItemType.Match">
            <summary>
            A match between two connections in two distinct genomes.
            </summary>
        </member>
        <member name="F:SharpNeat.Genomes.Neat.CorrelationItemType.Disjoint">
            <summary>
            A connection with no match in the other genome2 (that we are comparing with) and that has 
            an innovation ID less than the highest innovation ID in the other genome2,
            </summary>
        </member>
        <member name="F:SharpNeat.Genomes.Neat.CorrelationItemType.Excess">
            <summary>
            A connection with no match in the other genome2 (that we are comparing with) and that has 
            an innovation ID higher than the highest innovation ID in the other genome2.
            </summary>
        </member>
        <member name="T:SharpNeat.Genomes.Neat.ConnectionSelectionType">
            <summary>
            Different methods of determining which connection weights will be selected
            for mutation.
            </summary>
        </member>
        <member name="F:SharpNeat.Genomes.Neat.ConnectionSelectionType.Proportional">
            <summary>
            Select a proportion of the weights in a genome2.
            </summary>
        </member>
        <member name="F:SharpNeat.Genomes.Neat.ConnectionSelectionType.FixedQuantity">
            <summary>
            Select a fixed number of weights in a genome2.
            </summary>
        </member>
        <member name="T:SharpNeat.EvolutionAlgorithms.ComplexityRegulation.NullComplexityRegulationStrategy">
            <summary>
            Null strategy. Fixed to Complexifying mode.
            </summary>
        </member>
        <member name="T:SharpNeat.EvolutionAlgorithms.ComplexityRegulation.IComplexityRegulationStrategy">
            <summary>
            Represents a complexity regulation strategy. 
            
            DetermineMode() is called once per generation. The strategy can determine (and return) which mode
            the overall search should be in by examining the stats passed to the method. Thus the simplest 
            strategy is to just return ComplexityRegulationMode.Complexifying; this results in no complexity 
            regulation.
            
            Complexity regulation was known as phased search in SharpNEAT Version 1. For more information see:
            Phased Searching with NEAT: Alternating Between Complexification And Simplification, Colin Green, 2004
            (http://sharpneat.sourceforge.net/phasedsearch.html)
            </summary>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithms.ComplexityRegulation.IComplexityRegulationStrategy.DetermineMode(SharpNeat.EvolutionAlgorithms.NeatAlgorithmStats)">
            <summary>
            Determine which complexity regulation mode the search should be in given the provided
            NEAT algorithm stats.
            </summary>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithms.ComplexityRegulation.NullComplexityRegulationStrategy.DetermineMode(SharpNeat.EvolutionAlgorithms.NeatAlgorithmStats)">
            <summary>
            Determine which complexity regulation mode the search should be in given the provided
            NEAT algorithm stats.
            </summary>
        </member>
        <member name="T:SharpNeat.Decoders.HyperNeat.Substrate">
            <summary>
            HyperNEAT substrate. Encapsulates substrate nodes in sets and connections. Connections can be defined explicitly or 
            by providing mapping functions that map (connect) between nodes in sets. Node sets can be arranged as layers, however
            there is no limitation on node positions within the substrate - nodes in a set can be distributed throughout the substrate
            with no restrictions based on e.g. where nodes in other sets are located.
            </summary>
        </member>
        <member name="F:SharpNeat.Decoders.HyperNeat.Substrate.ConnectionCountCacheThreshold">
            <summary>
            The maximum number of substrate conenctions that we cache when using _nodeSetMappingList. If the number of 
            connections is less then this then we cache the susbstrate connections to avoid having to invoke the mapping 
            functions when creating/growing a network fromt the substrate.
            </summary>
        </member>
        <member name="F:SharpNeat.Decoders.HyperNeat.Substrate._nodeSetList">
            <summary>
            Substrate nodes, represented as distinct sets of nodes. By convention the first and second sets in the
            list represent the input and output noes respectively. All other sets represent hidden nodes.
            </summary>
        </member>
        <member name="F:SharpNeat.Decoders.HyperNeat.Substrate._activationFnLibrary">
            <summary>
            The activation function library allocated to the networks that are 'grown' from the substrate.
            _activationFnId refers to a function in this library.
            </summary>
        </member>
        <member name="F:SharpNeat.Decoders.HyperNeat.Substrate._activationFnId">
            <summary>
            The activation function ID that is uniformly allocated to all nodes in the netorks that are 'grown' 
            from the substrate.
            </summary>
        </member>
        <member name="F:SharpNeat.Decoders.HyperNeat.Substrate._nodeSetMappingList">
            <summary>
            A list of mapping functions that provide a means of obtaining a list of substrate connections 
            from the _nodeSetList. 
            </summary>
        </member>
        <member name="F:SharpNeat.Decoders.HyperNeat.Substrate._connectionList">
            <summary>
            Pre-built set of substrate connections.
            </summary>
        </member>
        <member name="F:SharpNeat.Decoders.HyperNeat.Substrate._connectionCountHint">
            <summary>
            A hint to the method creating networks from substrate - approximate number of connections that can be 
            expected to be grown by the substrate and it's mapping functions.
            </summary>
        </member>
        <member name="F:SharpNeat.Decoders.HyperNeat.Substrate._weightThreshold">
            <summary>
            The weight threshold below which substrate connections are not created in grown networks.
            </summary>
        </member>
        <member name="F:SharpNeat.Decoders.HyperNeat.Substrate._maxWeight">
            <summary>
            Defines the weight range of grown connections (+-maxWeight).
            </summary>
        </member>
        <member name="F:SharpNeat.Decoders.HyperNeat.Substrate._weightRescalingCoeff">
            <summary>
            Precalculated value for rescaling grown conenctions to the required weight range as described by _maxWeight.
            </summary>
        </member>
        <member name="F:SharpNeat.Decoders.HyperNeat.Substrate._netNodeList">
            <summary>
            Pre-built node list for creating new concrete network instances. This can be prebuilt because
            the set of nodes remains the same for each network instantiation, only the connections differ between
            instantiations.
            </summary>
        </member>
        <member name="F:SharpNeat.Decoders.HyperNeat.Substrate._inputNodeCount">
            <summary>
            The number of input nodes.
            </summary>
        </member>
        <member name="F:SharpNeat.Decoders.HyperNeat.Substrate._outputNodeCount">
            <summary>
            The number of output nodes.
            </summary>
        </member>
        <member name="F:SharpNeat.Decoders.HyperNeat.Substrate._dimensionality">
            <summary>
            Dimensionality of the substrate. The number of coordinate values in a node position; typically 2D or 3D.
            </summary>
        </member>
        <member name="M:SharpNeat.Decoders.HyperNeat.Substrate.#ctor(System.Collections.Generic.List{SharpNeat.Decoders.HyperNeat.SubstrateNodeSet},SharpNeat.Network.IActivationFunctionLibrary,System.Int32,System.Double,System.Double,System.Collections.Generic.List{SharpNeat.Decoders.HyperNeat.SubstrateConnection})">
            <summary>
            Construct a substrate with the provided node sets and a predetermined set of connections. 
            </summary>
            <param name="nodeSetList">Substrate nodes, represented as distinct sets of nodes. By convention the first and second
            sets in the list represent the input and output noes respectively. All other sets represent hidden nodes.</param>
            <param name="activationFnLibrary">The activation function library allocated to the networks that are 'grown' from the substrate.</param>
            <param name="activationFnId">The ID of an activation function function in activationFnLibrary. This is the activation function 
            ID assigned to all nodes in networks that are 'grown' from the substrate. </param>
            <param name="weightThreshold">The weight threshold below which substrate connections are not created in grown networks.</param>
            <param name="maxWeight">Defines the weight range of grown connections (+-maxWeight).</param>
            <param name="connectionList">A predetermined list of substrate connections.</param>
        </member>
        <member name="M:SharpNeat.Decoders.HyperNeat.Substrate.#ctor(System.Collections.Generic.List{SharpNeat.Decoders.HyperNeat.SubstrateNodeSet},SharpNeat.Network.IActivationFunctionLibrary,System.Int32,System.Double,System.Double,System.Collections.Generic.List{SharpNeat.Decoders.HyperNeat.NodeSetMapping})">
            <summary>
            Constructs with the provided substrate nodesets and mappings that describe how the nodesets are to be connected up.
            </summary>
            <param name="nodeSetList">Substrate nodes, represented as distinct sets of nodes. By convention the first and second
            sets in the list represent the input and output noes respectively. All other sets represent hidden nodes.</param>
            <param name="activationFnLibrary">The activation function library allocated to the networks that are 'grown' from the substrate.</param>
            <param name="activationFnId">The ID of an activation function function in activationFnLibrary. This is the activation function 
            ID assigned to all nodes in networks that are 'grown' from the substrate. </param>
            <param name="weightThreshold">The weight threshold below which substrate connections are not created in grown networks.</param>
            <param name="maxWeight">Defines the weight range of grown connections (+-maxWeight).</param>/// 
            <param name="nodeSetMappingList">A list of mappings between node sets that defines what connections to create between substrate nodes.</param>
        </member>
        <member name="M:SharpNeat.Decoders.HyperNeat.Substrate.CreateNetworkDefinition(SharpNeat.Phenomes.IBlackBox,System.Boolean)">
            <summary>
            Create a network definition by querying the provided IBlackBox (typically a CPPN) with the 
            substrate connection endpoints.
            </summary>
            <param name="blackbox">The HyperNEAT CPPN that defines the strength of connections between nodes on the substrate.</param>
            <param name="lengthCppnInput">Optionally we provide a connection length input to the CPPN.</param>
        </member>
        <member name="M:SharpNeat.Decoders.HyperNeat.Substrate.CalcBiasConnectionCountHint(System.Collections.Generic.List{SharpNeat.Decoders.HyperNeat.SubstrateNodeSet})">
            <summary>
            Calculate the maximum number of possible bias connections. Input nodes don't have a bias therefore this value
            is the number of hidden and output nodes.
            </summary>
        </member>
        <member name="M:SharpNeat.Decoders.HyperNeat.Substrate.CreateNetworkNodeList">
            <summary>
            Pre-build the network node list used for constructing new networks 'grown' on the substrate.
            This can be prebuilt because the set of nodes remains the same for each network instantiation,
            only the connections differ between instantiations.
            </summary>
        </member>
        <member name="M:SharpNeat.Decoders.HyperNeat.Substrate.CalculateConnectionLength(System.Double[],System.Double[])">
            <summary>
            Calculates the euclidean distance between two points in N dimensional space.
            </summary>
        </member>
        <member name="M:SharpNeat.Decoders.HyperNeat.Substrate.CalculateConnectionLength(System.Double[])">
            <summary>
            Calculates the euclidean distance between a point and the origin.
            </summary>
        </member>
        <member name="P:SharpNeat.Decoders.HyperNeat.Substrate.NodeSetList">
            <summary>
            Gets the list of substrate node sets. By convention the first nodeset describes the inputs nodes and the
            first node of that set describes the bias node. The last nodeset describes the output nodes.
            </summary>
        </member>
        <member name="T:SharpNeat.Core.ParallelGenomeListEvaluator`2">
            <summary>
            A concrete implementation of IGenomeListEvaluator that evaulates genomes independently of each 
            other and in parallel (on multiple execution threads).
            
            Genome decoding is performed by a provided IGenomeDecoder.
            Phenome evaluation is performed by a provided IPhenomeEvaluator.
            </summary>
        </member>
        <member name="T:SharpNeat.Core.IGenomeListEvaluator`1">
            <summary>
            Generic interface for evaluating a list of genomes. By operating on a list we allow concrete 
            implementations of this interface to choose between evaluating each genome2 independently of the others,
            perhaps across several execution threads, or in some collective evaluation scheme such as an artificial
            life/world scenario.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.IGenomeListEvaluator`1.Evaluate(System.Collections.Generic.IList{`0})">
            <summary>
            Evaluates a list of genomes.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.IGenomeListEvaluator`1.Reset">
            <summary>
            Reset the internal state of the evaluation scheme if any exists.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.IGenomeListEvaluator`1.EvaluationCount">
            <summary>
            Gets the total number of individual genome2 evaluations that have been performed by this evaluator.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.IGenomeListEvaluator`1.StopConditionSatisfied">
            <summary>
            Gets a value indicating whether some goal fitness has been achieved and that
            the the evolutionary algorithm search should stop. This property's value can remain false
            to allow the algorithm to run indefinitely.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.ParallelGenomeListEvaluator`2.#ctor(SharpNeat.Core.IGenomeDecoder{`0,`1},SharpNeat.Core.IPhenomeEvaluator{`1})">
            <summary>
            Construct with the provided IGenomeDecoder and IPhenomeEvaluator. 
            Phenome caching is enabled by default.
            The number of parallel threads defaults to Environment.ProcessorCount.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.ParallelGenomeListEvaluator`2.#ctor(SharpNeat.Core.IGenomeDecoder{`0,`1},SharpNeat.Core.IPhenomeEvaluator{`1},System.Threading.Tasks.ParallelOptions)">
            <summary>
            Construct with the provided IGenomeDecoder, IPhenomeEvaluator and ParalleOptions.
            Phenome caching is enabled by default.
            The number of parallel threads defaults to Environment.ProcessorCount.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.ParallelGenomeListEvaluator`2.#ctor(SharpNeat.Core.IGenomeDecoder{`0,`1},SharpNeat.Core.IPhenomeEvaluator{`1},System.Threading.Tasks.ParallelOptions,System.Boolean)">
            <summary>
            Construct with the provided IGenomeDecoder, IPhenomeEvaluator, ParalleOptions and enablePhenomeCaching flag.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.ParallelGenomeListEvaluator`2.Reset">
            <summary>
            Reset the internal state of the evaluation scheme if any exists.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.ParallelGenomeListEvaluator`2.Evaluate(System.Collections.Generic.IList{`0})">
            <summary>
            Evaluates a list of genomes. Here we decode each genome2 in using the contained IGenomeDecoder
            and evaluate the resulting TPhenome using the contained IPhenomeEvaluator.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.ParallelGenomeListEvaluator`2.Evaluate_NonCaching(System.Collections.Generic.IList{`0})">
            <summary>
            Main genome2 evaluation loop with no phenome caching (decode on each loop).
            </summary>
        </member>
        <member name="M:SharpNeat.Core.ParallelGenomeListEvaluator`2.Evaluate_Caching(System.Collections.Generic.IList{`0})">
            <summary>
            Main genome2 evaluation loop with phenome caching (decode only if no cached phenome is present
            from a previous decode).
            </summary>
        </member>
        <member name="P:SharpNeat.Core.ParallelGenomeListEvaluator`2.EvaluationCount">
            <summary>
            Gets the total number of individual genome2 evaluations that have been performed by this evaluator.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.ParallelGenomeListEvaluator`2.StopConditionSatisfied">
            <summary>
            Gets a value indicating whether some goal fitness has been achieved and that
            the the evolutionary algorithm/search should stop. This property's value can remain false
            to allow the algorithm to run indefinitely.
            </summary>
        </member>
        <member name="T:SharpNeat.Network.ReducedSigmoid">
            <summary>
            Sigmoid activation function with a gentler (reduced) slope compared to the PlainSimple function.
            </summary>
        </member>
        <member name="F:SharpNeat.Network.ReducedSigmoid.__DefaultInstance">
            <summary>
            Default instance provided as a public static field.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.ReducedSigmoid.Calculate(System.Double)">
            <summary>
            Calculates the output value for the specified input value.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.ReducedSigmoid.Calculate(System.Single)">
            <summary>
            Calculates the output value for the specified input value with float/single precision.
            This single precision overload of Calculate() will be used in neural network code 
            that has been specifically written to use floats instead of doubles.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.ReducedSigmoid.FunctionId">
            <summary>
            Gets the unique ID of the function. Stored in network XML to identify which function a network or neuron 
            is using.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.ReducedSigmoid.FunctionString">
            <summary>
            Gets a human readable string representation of the function. E.g 'y=1/x'.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.ReducedSigmoid.FunctionDescription">
            <summary>
            Gets a human readable verbose description of the activation function.
            </summary>
        </member>
        <member name="T:SharpNeat.Network.NodeList">
            <summary>
            Concrete implementation of INodeList.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.NodeList.#ctor">
            <summary>
            Constructs an empty list.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.NodeList.#ctor(System.Int32)">
            <summary>
            Constructs a list with the specified initial capacity.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.NodeList.BinarySearch(System.UInt32)">
            <summary>
            Gets the index of the INetworkNode with the specified ID. 
            Uses a binary search for fast searching, however this assumes the nodes are sorted by
            ID in ascending order.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.NodeList.IsSorted">
            <summary>
            Indicates if the nodes are sorted by ID in ascending order, as required by BinarySearch().
            For debug purposes only. Don't call this method in normal circumstances as it is an
            expensive O(n) operation.
            </summary>
        </member>
        <member name="T:SharpNeat.Network.INetworkNode">
            <summary>
            Represents a single network node.
            Part of the INetworkDefinition type hierarchy.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.INetworkNode.Id">
            <summary>
            Gets the node's unique ID.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.INetworkNode.NodeType">
            <summary>
            Gets the node's type.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.INetworkNode.ActivationFnId">
            <summary>
            Gets the node's activation function ID. This is an ID into an IActivationFunctionLibrary
            associated with the network as a whole.
            </summary>
        </member>
        <member name="T:SharpNeat.Genomes.Neat.ConnectionPerturbanceType">
            <summary>
            Defines types of weight perturbance.
            </summary>
        </member>
        <member name="F:SharpNeat.Genomes.Neat.ConnectionPerturbanceType.Reset">
            <summary>
            Reset weight.
            </summary>
        </member>
        <member name="F:SharpNeat.Genomes.Neat.ConnectionPerturbanceType.JiggleUniform">
            <summary>
            Jiggle weight using deltas from a uniform distribution.
            </summary>
        </member>
        <member name="F:SharpNeat.Genomes.Neat.ConnectionPerturbanceType.JiggleGaussian">
            <summary>
            Jiggle weight using deltas from a Gaussian distribution.
            </summary>
        </member>
        <member name="T:SharpNeat.Genomes.Neat.ConnectionMutationInfo">
            <summary>
            Each instance of ConnectionMutationInfo describes a type of mutation and associated parameters.
            
            A list of ConnectionMutationInfo objects describe a connection weight mutation scheme - a set
            of a number of different types of mutation along with the probability of each type occuring
            when spawning offspring genomes asexually.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.ConnectionMutationInfo.#ctor(System.Double,SharpNeat.Genomes.Neat.ConnectionPerturbanceType,SharpNeat.Genomes.Neat.ConnectionSelectionType,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            Construct with the provided mutation type and supporting parameters.
            </summary>
            <param name="activationProbability">The probability that this type of mutation will be chosen</param>
            <param name="perturbanceType">The type of weight perturbance the info object represents.</param>
            <param name="selectionType">The type of connection subset selection the info object represents.</param>
            <param name="selectionProportion">For ConnectionSelectionType.Proportional this gives the proportion of connections to select.</param>
            <param name="selectionQuantity">For ConnectionSelectionType.FixedQuantity this gives the number of connections to select.</param>
            <param name="perturbanceMagnitude">For ConnectionPerturbanceType.JiggleEven this gives the magnitude of the extents of the 
            even distribution used for generating jiggle weight deltas.</param>
            <param name="sigma">For For ConnectionPerturbanceType.JiggleGaussian this specifies the sigma to use for
            the gaussian distribution used for generating jiggle weight deltas.</param>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.ConnectionMutationInfo.#ctor(SharpNeat.Genomes.Neat.ConnectionMutationInfo)">
            <summary>
            Copy constructor.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.ConnectionMutationInfo.ActivationProbability">
            <summary>
            Gets the probability that this type of mutation will be chosen.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.ConnectionMutationInfo.PerturbanceType">
            <summary>
            Gets the type of weight perturbance the info object represents.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.ConnectionMutationInfo.SelectionType">
            <summary>
            Gets the type of connection subset selection the info object represents.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.ConnectionMutationInfo.SelectionProportion">
            <summary>
            Gets  the proportion of connections to select; for ConnectionSelectionType.Proportional.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.ConnectionMutationInfo.SelectionQuantity">
            <summary>
            Gets the number of connections to select; for ConnectionSelectionType.FixedQuantity.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.ConnectionMutationInfo.PerturbanceMagnitude">
            <summary>
            Gets the magnitude of the extents of the even distribution used for generating jiggle weight deltas; for ConnectionPerturbanceType.JiggleEven.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.ConnectionMutationInfo.Sigma">
            <summary>
            Gets the sigma to use for the gaussian distribution used for generating jiggle weight deltas; for ConnectionPerturbanceType.JiggleGaussian.
            </summary>
        </member>
        <member name="T:SharpNeat.Genomes.Neat.ConnectionGene">
            <summary>
            A gene that represents a single connection between neurons in NEAT.
            </summary>
        </member>
        <member name="T:SharpNeat.Network.INetworkConnection">
            <summary>
            Represents a single network connection.
            Part of the INetworkDefinition type hierarchy.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.INetworkConnection.SourceNodeId">
            <summary>
            Gets the ID of the connection's source node.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.INetworkConnection.TargetNodeId">
            <summary>
            Gets the ID of the connection's target node.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.INetworkConnection.Weight">
            <summary>
            Gets the connection's weight.
            </summary>
        </member>
        <member name="F:SharpNeat.Genomes.Neat.ConnectionGene._isMutated">
            <summary>
            Used by the connection mutation routine to flag mutated connections so that they aren't
            mutated more than once.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.ConnectionGene.#ctor(SharpNeat.Genomes.Neat.ConnectionGene)">
            <summary>
            Copy constructor.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.ConnectionGene.#ctor(System.UInt32,System.UInt32,System.UInt32,System.Double,System.Double)">
            <summary>
            Construct a new ConnectionGene with the specified source and target neurons and connection weight.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.ConnectionGene.CreateCopy">
            <summary>
            Creates a copy of the current gene. Virtual method that can be overriden by sub-types.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.ConnectionGene.InnovationId">
            <summary>
            Gets or sets the gene's innovation ID.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.ConnectionGene.SourceNodeId">
            <summary>
            Gets or sets the gene's source neuron/node ID.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.ConnectionGene.TargetNodeId">
            <summary>
            Gets or sets the gene's target neuron/node ID.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.ConnectionGene.Weight">
            <summary>
            Gets or sets the gene's connection weight.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.ConnectionGene.Sigma">
            <summary>
            The sigma that this gene uses during Gaussian mutation.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.ConnectionGene.IsMutated">
            <summary>
            Gets or sets a value indicating whether this gene has been mutated. This allows the mutation routine to avoid mutating
            genes it has already operated on. These flags are reset for all Connection genes within a NeatGenome on exiting
            the mutation routine.
            </summary>
        </member>
        <member name="T:SharpNeat.Decoders.RecurrentNetworkFactory">
            <summary>
            Static factory for creating RecurrentNetwork's from INetworkDefinition's.
            </summary>
        </member>
        <member name="M:SharpNeat.Decoders.RecurrentNetworkFactory.CreateRecurrentNetwork(SharpNeat.Network.INetworkDefinition,SharpNeat.Decoders.NetworkActivationScheme)">
            <summary>
            Creates a RecurrentNetwork from an INetworkDefinition.
            </summary>
        </member>
        <member name="T:SharpNeat.Utility.RouletteWheel">
            <summary>
            Static methods for roulette wheel selection from a set of choices with predefined probabilities.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.RouletteWheel.SingleThrow(System.Double,SharpNeat.Utility.FastRandom)">
            <summary>
            A simple single throw routine.
            </summary>
            <param name="probability">A probability between 0..1 that the throw will result in a true result.</param>
            <param name="rng">Random number generator.</param>
        </member>
        <member name="M:SharpNeat.Utility.RouletteWheel.SingleThrowEven(System.Int32,SharpNeat.Utility.FastRandom)">
            <summary>
            Performs a single throw for a given number of outcomes with equal probabilities.
            </summary>
            <param name="numberOfOutcomes">The number of possible outcomes.</param>
            <param name="rng">Random number generator.</param>
            <returns>An integer between 0..numberOfOutcomes-1. In effect this routine selects one of the possible outcomes.</returns>
        </member>
        <member name="M:SharpNeat.Utility.RouletteWheel.SingleThrow(SharpNeat.Utility.RouletteWheelLayout,SharpNeat.Utility.FastRandom)">
            <summary>
            Performs a single throw onto a roulette wheel where the wheel's space is unevenly divided between outcomes.
            The probabilty that a segment will be selected is given by that segment's value in the 'probabilities'
            array within the specified RouletteWheelLayout. The probabilities within a RouletteWheelLayout have already 
            been normalised so that their total is always equal to 1.0.
            </summary>
            <param name="layout">The roulette wheel layout.</param>
            <param name="rng">Random number generator.</param>
        </member>
        <member name="M:SharpNeat.Utility.RouletteWheel.SingleThrow(SharpNeat.Utility.RouletteWheelLayout,SharpNeat.Utility.FastRandom,System.Int32)">
            <summary>
            Performs a single throw onto a roulette wheel where the wheel's space is unevenly divided between outcomes.
            The probabilty that a segment will be selected is given by that segment's value in the 'probabilities'
            array within the specified RouletteWheelLayout. The probabilities within a RouletteWheelLayout have already 
            been normalised so that their total is always equal to 1.0.
            
            This overload of SingleThrow() allows one of the segments of the roulette wheel to be eliminated. The item at
            skipIdx will not be selected. As such there must be at least one other non-zero probability item in addition to
            the one being avoided/skipped; if there is not then -1 is returned to indicate that no item was selected.
            </summary>
            <param name="layout">The roulette wheel layout.</param>
            <param name="rng">Random number generator.</param>
            <param name="skipIdx">The index of the probability/item to avoid.</param>
        </member>
        <member name="T:SharpNeat.Utility.DoubleCircularBufferWithStats">
             <summary>
             This is a circular buffer of double precision floating point numbers. 
             A circular buffer must be assigned a capacity at construction time. Values
             can be enqueued indefintely, but when the buffer's capacity is reached the oldest values
             in the buffer are overwritten, thus the buffer is best thought of as a circular array 
             or buffer.
            
             In addition to normal circular buffer behaviour this class has a 'total' variable that
             maintains the sum total of all values currently in the buffer. Therefore when the buffer 
             reaches capacity and new values overwrite old ones the total is reduced by the value being
             overwritten and increased by the new value. This allows us to cheaply (in computational terms)
             maintain a sum total and mean for all values in the buffer.
             
             Note that this class isn't made generic because of the lack of operator contraints required 
             to maintain the sum total of contained items. There are ways around this limitation but they
             affect performance or result in ugly code.
             </summary>
        </member>
        <member name="F:SharpNeat.Utility.DoubleCircularBufferWithStats._buff">
            <summary>
            Internal array that stores the circular buffer's values.
            </summary>
        </member>
        <member name="F:SharpNeat.Utility.DoubleCircularBufferWithStats._total">
            <summary>
            The sum total of all valid values within the buffer. 
            </summary>
        </member>
        <member name="F:SharpNeat.Utility.DoubleCircularBufferWithStats._headIdx">
            <summary>
            The index of the previously enqueued item. -1 if buffer is empty.
            </summary>
        </member>
        <member name="F:SharpNeat.Utility.DoubleCircularBufferWithStats._tailIdx">
            <summary>
            The index of the next item to be dequeued. -1 if buffer is empty.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.DoubleCircularBufferWithStats.#ctor(System.Int32)">
            <summary>
            Constructs a circular buffer with the specified capacity.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.DoubleCircularBufferWithStats.Clear">
            <summary>
            Clear the buffer and reset the total.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.DoubleCircularBufferWithStats.Enqueue(System.Double)">
            <summary>
            Enqueue a new value. This overwrites the oldest value in the buffer if the buffer
            has reached capacity.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.DoubleCircularBufferWithStats.Dequeue">
            <summary>
            Remove the oldest value from the back end of the buffer and return it.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.DoubleCircularBufferWithStats.Pop">
            <summary>
            Pop the most recently added value from the front end of the buffer and return it.
            </summary>
        </member>
        <member name="P:SharpNeat.Utility.DoubleCircularBufferWithStats.Length">
            <summary>
            Gets the number of values in the buffer. Returns the buffer's capacity if it is full.
            </summary>
        </member>
        <member name="P:SharpNeat.Utility.DoubleCircularBufferWithStats.Total">
            <summary>
            Gets the sum total of all values on in the buffer.
            </summary>
        </member>
        <member name="P:SharpNeat.Utility.DoubleCircularBufferWithStats.Mean">
            <summary>
            Gets the arithmetic mean of all values in the buffer.
            </summary>
        </member>
        <member name="T:SharpNeat.Network.NodeType">
            <summary>
            Enum of network node types.
            </summary>
        </member>
        <member name="F:SharpNeat.Network.NodeType.Bias">
            <summary>
            Bias node. Output is fixed to 1.0
            </summary>
        </member>
        <member name="F:SharpNeat.Network.NodeType.Input">
            <summary>
            Input node.
            </summary>
        </member>
        <member name="F:SharpNeat.Network.NodeType.Output">
            <summary>
            Output node.
            </summary>
        </member>
        <member name="F:SharpNeat.Network.NodeType.Hidden">
            <summary>
            Hidden node.
            </summary>
        </member>
        <member name="T:SharpNeat.Phenomes.NeuralNets.FastRelaxingRecurrentNetwork">
            <summary>
            A version of FastRecurrentNetwork that activates a network until it becomes 'relaxed' rather
            than for some fixed number of iterations. This class is exactly the same as FastRecurrentNetwork
            in all other respects; See that class for more detailed info.
            
            A network is defined as being relaxed when the change in output signal value between two successive
            update iterations is less than some threshold value (defined by maxAllowedSignalDelta on the constructor)
            for all hidden and output neurons (inpus and bias neurons have a fixed output value).
            </summary>
        </member>
        <member name="T:SharpNeat.Phenomes.NeuralNets.FastRecurrentNetwork">
            <summary>
            A neural network class that represents a network with recurrent (cyclic) connections. 
            
            This is a much faster implementation of RecurrentNetwork. The speedup is approximately 5x depending on 
            hardware and CLR platform, see http://sharpneat.sourceforge.net/network_optimization.html for detailed info.
            
            The speedup is achieved by compactly storing all required data in arrays and in a way that maximizes
            in-order memory accesses; This allows us to maximize use of CPU caches. In contrast the RecurrentNetwork
            class represents the network directly, that is, as a network of neuron/node objects; This has additional
            overhead such as the standard data associated with each object in dotNet which results in less efficient
            packing of the true neural net data in memory, which in turns results in less efficient use of CPU memory 
            caches. Finally, representing the network directly as a graph of connected nodes is not conducive to 
            writing code with in-order memory accesses.
            
            Algorithm overview.
            1) Loop connections. Each connection gets its input signal from its source neuron, applies its weight and
            stores its output value./ Connections are ordered by source neuron index, thus all memory accesses here are
            sequential/in-order.
            
            2) Loop connections (again). Each connection adds its output value to its target neuron, thus each neuron  
            accumulates or 'collects' its input signal in its pre-activation variable. Because connections are sorted by
            source neuron index and not target index, this loop generates out-of order memory accesses, but is the only 
            loop to do so.
            
            3) Loop neurons. Pass each neuron's pre-activation signal through the activation function and set its 
            post-activation signal value. 
            
            The activation loop is now complete and we can go back to (1) or stop.
            </summary>
        </member>
        <member name="M:SharpNeat.Phenomes.NeuralNets.FastRecurrentNetwork.#ctor(SharpNeat.Phenomes.NeuralNets.FastConnection[],SharpNeat.Network.IActivationFunction[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs a FastRecurrentNetwork with the provided pre-built FastConnection array and 
            associated data.
            </summary>
        </member>
        <member name="M:SharpNeat.Phenomes.NeuralNets.FastRecurrentNetwork.Activate">
            <summary>
            Activate the network for a fixed number of iterations defined by the 'maxIterations' parameter
            at construction time. Activation reads input signals from InputSignalArray and writes output signals
            to OutputSignalArray.
            </summary>
        </member>
        <member name="M:SharpNeat.Phenomes.NeuralNets.FastRecurrentNetwork.ResetState">
            <summary>
            Reset the network's internal state.
            </summary>
        </member>
        <member name="P:SharpNeat.Phenomes.NeuralNets.FastRecurrentNetwork.InputCount">
            <summary>
            Gets the number of inputs.
            </summary>
        </member>
        <member name="P:SharpNeat.Phenomes.NeuralNets.FastRecurrentNetwork.OutputCount">
            <summary>
            Gets the number of outputs.
            </summary>
        </member>
        <member name="P:SharpNeat.Phenomes.NeuralNets.FastRecurrentNetwork.InputSignalArray">
            <summary>
            Gets an array for feeding input signals to the network.
            </summary>
        </member>
        <member name="P:SharpNeat.Phenomes.NeuralNets.FastRecurrentNetwork.OutputSignalArray">
            <summary>
            Gets an array of output signals from the network.
            </summary>
        </member>
        <member name="P:SharpNeat.Phenomes.NeuralNets.FastRecurrentNetwork.IsStateValid">
            <summary>
            Gets a value indicating whether the internal state is valid. Always returns true for this class.
            </summary>
        </member>
        <member name="M:SharpNeat.Phenomes.NeuralNets.FastRelaxingRecurrentNetwork.#ctor(SharpNeat.Phenomes.NeuralNets.FastConnection[],SharpNeat.Network.IActivationFunction[],System.Int32,System.Int32,System.Int32,System.Int32,System.Double)">
            <summary>
            Constructs a FastRelaxingRecurrentNetwork with the provided pre-built FastConnection array and 
            associated data.
            </summary>
        </member>
        <member name="M:SharpNeat.Phenomes.NeuralNets.FastRelaxingRecurrentNetwork.Activate">
            <summary>
            Activate the network until it becomes 'relaxed' or until maxIterations is reached. If maxIterations 
            is reached without the network relaxing then the IsValidState property will return false, although 
            the network outputs are still provided and can be read as normal.
            </summary>
        </member>
        <member name="P:SharpNeat.Phenomes.NeuralNets.FastRelaxingRecurrentNetwork.IsStateValid">
            <summary>
            Gets a value indicating whether the internal state is valid. Returns false if the network did not relax within the
            maximum number of timesteps.
            </summary>
        </member>
        <member name="T:SharpNeat.Network.AbsoluteRoot">
            <summary>
            Absolute root activation function with clipping. The square root of the absolute (magnitude) of the
            input value, with output value clipped to maximum of +1.0
            </summary>
        </member>
        <member name="F:SharpNeat.Network.AbsoluteRoot.__DefaultInstance">
            <summary>
            Default instance provided as a public static field.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.AbsoluteRoot.Calculate(System.Double)">
            <summary>
            Calculates the output value for the specified input value.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.AbsoluteRoot.Calculate(System.Single)">
            <summary>
            Calculates the output value for the specified input value with float/single precision.
            This single precision overload of Calculate() will be used in neural network code 
            that has been specifically written to use floats instead of doubles.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.AbsoluteRoot.FunctionId">
            <summary>
            Gets the unique ID of the function. Stored in network XML to identify which function a network or neuron 
            is using.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.AbsoluteRoot.FunctionString">
            <summary>
            Gets a human readable string representation of the function. E.g 'y=1/x'.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.AbsoluteRoot.FunctionDescription">
            <summary>
            Gets a human readable verbose description of the activation function.
            </summary>
        </member>
        <member name="T:SharpNeat.Genomes.Neat.NeatGenomeParameters">
            <summary>
            Represents parameters specific to NEAT genomes. E.g. parameters that describe probabilities
            for the different types of mutation and the proportion of possible connections to instantiate 
            between input and output neurons within the initial population.
            </summary>
        </member>
        <member name="F:SharpNeat.Genomes.Neat.NeatGenomeParameters._connectionMutationInfoList">
            <summary>
            A list of ConnectionMutationInfo objects that drives the types of connection mutation
            that occur.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenomeParameters.#ctor">
            <summary>
            Construct with default set of parameters.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenomeParameters.#ctor(SharpNeat.Genomes.Neat.NeatGenomeParameters)">
            <summary>
            Copy constructor.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenomeParameters.CreateConnectionWeightMutationScheme_Default">
            <summary>
            Returns the default connection weight mutation scheme.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenomeParameters.CreateConnectionWeightMutationScheme_SharpNEAT1">
            <summary>
            Returns the connection weight mutation scheme from SharpNEAT version 1.x
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenomeParameters.CreateSimplifyingParameters(SharpNeat.Genomes.Neat.NeatGenomeParameters)">
            <summary>
            Creates parameters suitable for use during the simplifying mode of a NEAT search. Addition 
            mutations are disabled, deletion and weight mutation rates are increased.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenomeParameters.SelfAdaptive">
            <summary>
            Gets or sets the flag that indicates if mutation rates are self-adaptive.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenomeParameters.ActivationFn">
            <summary>
            Gets or sets the neuron activation function to use in evolved networks. NEAT uses the same activation
            function at each node.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenomeParameters.ConnectionWeightRange">
            <summary>
            Gets or sets the connection weight range to use in NEAT genomes. E.g. a value of 5 defines a weight range
            of -5 to 5. The weight range is strictly enforced - e.g. when creating new connections and mutating
            existing ones.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenomeParameters.InitialInterconnectionsProportion">
            <summary>
            Gets or sets a proportion that specifies the number of interconnections to make between input and 
            output neurons in an initial random population. This is a proportion of the total number of
            possible interconnections.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenomeParameters.DisjointExcessGenesRecombinedProbability">
            <summary>
            Gets or sets the probability that all excess and disjoint genes are copied into an offspring genome2
            during sexual reproduction. Currently the execss/disjoint genes are copied in an all or nothing 
            strategy.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenomeParameters.ConnectionWeightMutationProbability">
            <summary>
            Gets or sets the probability that a genome2 mutation operates on genome2 connection weights.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenomeParameters.AddNodeMutationProbability">
            <summary>
            Gets or sets the probability that a genome2 mutation is an 'add node' mutation.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenomeParameters.AddConnectionMutationProbability">
            <summary>
            Gets or sets the probability that a genome2 mutation is an 'add connection' mutation.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenomeParameters.DeleteConnectionMutationProbability">
            <summary>
            Gets or sets the probability that a genome2 mutation is a 'delete connection' mutation.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenomeParameters.DeleteSimpleNeuronMutationProbability">
            <summary>
            Gets or sets the probability that a genome2 mutation is a 'delete simple neuron' mutation (neurons with a single incoming and/or outgoign connection).
            The neuron is fctored out of the network by replacing it with connections that connect up all neurons on its source and target side, thus maintaining 
            the same connectivity.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenomeParameters.RouletteWheelLayout">
            <summary>
            Gets a RouletteWheelLayout that represents the probabilities of each type of genome2 mutation.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenomeParameters.RouletteWheelLayoutNonDestructive">
            <summary>
            Gets an alternative RouletteWheelLayout for use when we wish to avoid deletion mutations, 
            e.g. when  mutating a genome2 with just one connection.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenomeParameters.ConnectionMutationInfoList">
            <summary>
            Gets a list of ConnectionMutationInfo objects that drives the types of connection mutation
            that occur.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenomeParameters.FitnessHistoryLength">
            <summary>
            Gets or sets the fitness history length to be used by genomes when recording their fitness.
            </summary>
        </member>
        <member name="T:SharpNeat.Genomes.Neat.ConnectionGeneComparer">
            <summary>
            Compares the innovation ID of ConnectionGenes.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.ConnectionGeneComparer.Compare(SharpNeat.Genomes.Neat.ConnectionGene,SharpNeat.Genomes.Neat.ConnectionGene)">
            <summary>
            Compare the two genes. Returns -1 if x is before y.
            </summary>
        </member>
        <member name="T:SharpNeat.Genomes.Neat.ConnectionGeneListBuilder">
            <summary>
            Used for building a list of connection genes. 
            
            Connection genes are added one by one to a list and a dictionary of added connection genes is maintained
            keyed on ConnectionEndpointsStruct to allow a caller to check if a connection with the same end points
            (and potentially a different innovation ID) already exists in the list.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.ConnectionGeneListBuilder.#ctor(System.Int32)">
            <summary>
            Constructs the builder with the provided capacity. The capacity should be chosen 
            to limit the number of memory re-allocations that occur within the contained
            connection list dictionary.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.ConnectionGeneListBuilder.Append(SharpNeat.Genomes.Neat.ConnectionGene,SharpNeat.Network.ConnectionEndpointsStruct)">
            <summary>
            Add a connection gene. Register it with the connection gene dictionary (keyed on end points,
            not on innovation ID) and register the neuron IDs (from the connection end points) with the neuron 
            ID dictionary.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.ConnectionGeneListBuilder.ConnectionGeneList">
            <summary>
            Gets the contained list of connection genes.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.ConnectionGeneListBuilder.ConnectionGeneDictionary">
            <summary>
            Gets the builder's dictionary of connection genes keyed on ConnectionEndpointsStruct.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.ConnectionGeneListBuilder.NeuronIdDictionary">
            <summary>
            Gets the builder's dictionary of neuron IDs obtained from contained connection gene endpoints.
            </summary>
        </member>
        <member name="T:SharpNeat.Genomes.Neat.NeatGenomeXmlIO">
            <summary>
            Static class for reading and writing NeatGenome(s) to and from XML.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenomeXmlIO.SaveComplete(SharpNeat.Genomes.Neat.NeatGenome,System.Boolean)">
            <summary>
            Writes a single NeatGenome to XML within a containing 'Root' element and the activation function
            library that the genome2 is associated with.
            The XML is returned as a newly created XmlDocument.
            </summary>
            <param name="genome">The genome to save.</param>
            <param name="nodeFnIds">Indicates if node activation function IDs should be emitted. They are required
            for HyperNEAT genomes but not for NEAT.</param>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenomeXmlIO.SaveComplete(System.Collections.Generic.IList{SharpNeat.Genomes.Neat.NeatGenome},System.Boolean)">
            <summary>
            Writes a list of NeatGenome(s) to XML within a containing 'Root' element and the activation
            function library that the genomes are associated with.
            The XML is returned as a newly created XmlDocument.
            </summary>
            <param name="genomeList">List of genomes to write as XML.</param>
            <param name="nodeFnIds">Indicates if node activation function IDs should be emitted. They are required
            for HyperNEAT genomes but not for NEAT.</param>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenomeXmlIO.Save(SharpNeat.Genomes.Neat.NeatGenome,System.Boolean)">
            <summary>
            Writes a single NeatGenome to XML.
            The XML is returned as a newly created XmlDocument.
            </summary>
            <param name="genome">The genome to save.</param>
            <param name="nodeFnIds">Indicates if node activation function IDs should be emitted. They are required
            for HyperNEAT genomes but not for NEAT.</param>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenomeXmlIO.LoadCompleteGenomeList(System.Xml.XmlNode,System.Boolean,SharpNeat.Genomes.Neat.NeatGenomeParameters)">
            <summary>
            Loads a list of NeatGenome(s) from XML that has a containing 'Root' element. The root element 
            also contains the activation function library that the network definitions are associated with.
            </summary>
            <param name="xmlNode">The XmlNode to read from. This can be an XmlDocument or XmlElement.</param>
            <param name="nodeFnIds">Indicates if node activation function IDs should be read. If false then 
            all node activation function IDs default to 0.</param>
            <param name="genomeParameters">A NeatGenomeParameters object to construct genomes and their 
            associated NeatGenomeFactory against.</param>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenomeXmlIO.LoadCompleteGenomeList(System.Xml.XmlNode,System.Boolean)">
            <summary>
            Reads a list of NeatGenome(s) from XML that has a containing 'Root' element. The root element 
            also contains the activation function library that the network definitions are associated with.
            </summary>
            <param name="xmlNode">The XmlNode to read from. This can be an XmlDocument or XmlElement.</param>
            <param name="nodeFnIds">Indicates if node activation function IDs should be read. If false then 
            all node activation function IDs default to 0.</param>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenomeXmlIO.LoadGenome(System.Xml.XmlNode,System.Boolean)">
            <summary>
            Reads a NeatGenome from XML.
            </summary>
            <param name="xmlNode">The XmlNode to read from. This can be an XmlDocument or XmlElement.</param>
            <param name="nodeFnIds">Indicates if node activation function IDs should be read. They are required
            for HyperNEAT genomes but not for NEAT</param>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenomeXmlIO.WriteComplete(System.Xml.XmlWriter,System.Collections.Generic.IList{SharpNeat.Genomes.Neat.NeatGenome},System.Boolean)">
            <summary>
            Writes a list of NeatGenome(s) to XML within a containing 'Root' element and the activation
            function library that the genomes are associated with.
            </summary>
            <param name="xw">XmlWriter to write XML to.</param>
            <param name="genomeList">List of genomes to write as XML.</param>
            <param name="nodeFnIds">Indicates if node activation function IDs should be emitted. They are required
            for HyperNEAT genomes but not for NEAT.</param>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenomeXmlIO.WriteComplete(System.Xml.XmlWriter,SharpNeat.Genomes.Neat.NeatGenome,System.Boolean)">
            <summary>
            Writes a single NeatGenome to XML within a containing 'Root' element and the activation
            function library that the genome2 is associated with.
            </summary>
            <param name="xw">XmlWriter to write XML to.</param>
            <param name="genome">Genome to write as XML.</param>
            <param name="nodeFnIds">Indicates if node activation function IDs should be emitted. They are required
            for HyperNEAT genomes but not for NEAT.</param>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenomeXmlIO.Write(System.Xml.XmlWriter,SharpNeat.Genomes.Neat.NeatGenome,System.Boolean)">
            <summary>
            Writes a NeatGenome to XML.
            </summary>
            <param name="xw">XmlWriter to write XML to.</param>
            <param name="genome">Genome to write as XML.</param>
            <param name="nodeFnIds">Indicates if node activation function IDs should be emitted. They are required
            for HyperNEAT genomes but not for NEAT.</param>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenomeXmlIO.ReadCompleteGenomeList(System.Xml.XmlReader,System.Boolean)">
            <summary>
            Reads a list of NeatGenome(s) from XML and from within a containing 'Root' element and packaged
            alongside XML describing the activation function library that the genomes are associated with.
            </summary>
            <param name="xr">The XmlReader to read from.</param>
            <param name="nodeFnIds">Indicates if node activation function IDs should be read. If false then 
            all node activation function IDs default to 0.</param>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenomeXmlIO.ReadCompleteGenomeList(System.Xml.XmlReader,System.Boolean,SharpNeat.Genomes.Neat.NeatGenomeParameters)">
            <summary>
            Reads a list of NeatGenome(s) from XML that has a containing 'Root' element. The root 
            element also contains the activation function library that the genomes are associated with.
            </summary>
            <param name="xr">The XmlReader to read from.</param>
            <param name="nodeFnIds">Indicates if node activation function IDs should be read. If false then 
            all node activation function IDs default to 0.</param>
            <param name="genomeParameters">A NeatGenomeParameters object to construct genomes and their 
            associated NeatGenomeFactory against.</param>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenomeXmlIO.ReadGenome(System.Xml.XmlReader,System.Boolean)">
            <summary>
            Reads a NeatGenome from XML.
            </summary>
            <param name="xr">The XmlReader to read from.</param>
            <param name="nodeFnIds">Indicates if node activation function IDs should be read. They are required
            for HyperNEAT genomes but not for NEAT</param>
        </member>
        <member name="T:SharpNeat.DistanceMetrics.ManhattanDistanceMetric">
            <summary>
            Manhattan distance metric.
            
            The Manhattan distance is simply the sum total of all of the distances in each dimension. 
            Also known as the taxicab distance, rectilinear distance, L1 distance or L1 norm.
            
            Use the default constructor for classical Manhattan Distance.
            Optionally the constructor can be provided with a two coefficients and a constant that can be used to modify/distort
            distance measures. These are:
            
            matchDistanceCoeff - When comparing two positions in the same dimension the distance between those two position is 
            multiplied by this coefficient.
            
            mismatchDistanceCoeff, mismatchDistanceConstant - When comparing two coordinates where one describes a position in a given 
            dimenasion and the other does not then the second coordinate is assumed to be at position zero in that dimension. However,
            the resulting distance is multiplied by this coefficient and mismatchDistanceConstant is added, therefore allowing matches and 
            mismatches to be weighted differently, e.g. more emphasis can be placed on mismatches (and therefore network topology).
            If mismatchDistanceCoeff is zero and mismatchDistanceConstant is non-zero then the distance of mismatches is a fixed value.
            
            The two coefficients and constant allow the following schemes:
            
            1) Classical Manhattan distance.
            2) Topology only distance metric (ignore connections weights).
            3) Equivalent of genome2 distance in Original NEAT (O-NEAT). This is actually a mix of (1) and (2).
            </summary>
        </member>
        <member name="T:SharpNeat.Core.IDistanceMetric">
            <summary>
            An IDistanceMetric represents a metric for measuring the distance between two genome2 positions in an
            encoding space, and thus the compatibility of the two genomes with respect to the probability of creating
            fit offspring.
            
            What makes a good or ideal compatibility metric is an open question at the time of writing (August-2009).
            </summary>
        </member>
        <member name="M:SharpNeat.Core.IDistanceMetric.MeasureDistance(SharpNeat.Core.CoordinateVector,SharpNeat.Core.CoordinateVector,System.Double)">
            <summary>
            Tests if the distance between the two positions is greater than some threshold.
            
            A simple way of implementing this method would be to calculate the distance between the
            two genomes and test if it is over the threshold. That approach requires that the internal
            data of both positions be fully compared. However, it is faster to compare the contents of the
            two positions maintaining an accumulated distance value as we progress through the comparison, 
            and to return out of the method when and if the threshold is passed. Writing distance metric 
            code in this way is encouraged.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.IDistanceMetric.MeasureDistance(SharpNeat.Core.CoordinateVector,SharpNeat.Core.CoordinateVector)">
            <summary>
            Measures the distance between two positions.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.IDistanceMetric.CalculateCentroid(System.Collections.Generic.IList{SharpNeat.Core.CoordinateVector})">
            <summary>
            Calculates the centroid for the given set of points.
            The centroid is a central position within a set of points that minimizes the sum of the squared distance
            between each of those points and the centroid. As such it can also be thought of as being an exemplar 
            for a set of points.
            
            The centroid calculation is dependent on the distance metric, hence this method is defined on IDistanceMetric.
            For some distance metrics the centroid may not be a unique point, in those cases one of the possible centroids
            is returned.
            
            A centroid is used in k-means clustering to define the center of a cluster.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.IDistanceMetric.CalculateCentroidParallel(System.Collections.Generic.IList{SharpNeat.Core.CoordinateVector})">
            <summary>
            Parallelized version of CalculateCentroid().
            </summary>
        </member>
        <member name="F:SharpNeat.DistanceMetrics.ManhattanDistanceMetric._matchDistanceCoeff">
            <summary>A coefficient to applied to the distance obtained from two coordinates that both 
            describe a position in a given dimension.</summary>
        </member>
        <member name="F:SharpNeat.DistanceMetrics.ManhattanDistanceMetric._mismatchDistanceCoeff">
            <summary>A coefficient applied to the distance obtained from two coordinates where only one of the coordinates describes
            a position in a given dimension. The other point is taken to be at position zero in that dimension.</summary>
        </member>
        <member name="F:SharpNeat.DistanceMetrics.ManhattanDistanceMetric._mismatchDistanceConstant">
            <summary>A constant that is added to the distance where only one of the coordinates describes a position in a given dimension.
            This adds extra emphasis to distance when comparing coordinates that exist in different dimesions.</summary>
        </member>
        <member name="M:SharpNeat.DistanceMetrics.ManhattanDistanceMetric.#ctor">
            <summary>
            Constructs using default weightings for comparisons on matching and mismatching dimensions.
            Classical Manhattan Distance.
            </summary>
        </member>
        <member name="M:SharpNeat.DistanceMetrics.ManhattanDistanceMetric.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Constructs using the provided weightings for comparisons on matching and mismatching dimensions.
            </summary>
            <param name="matchDistanceCoeff">A coefficient to applied to the distance obtained from two coordinates that both 
            describe a position in a given dimension.</param>
            <param name="mismatchDistanceCoeff">A coefficient applied to the distance obtained from two coordinates where only one of the coordinates describes
            a position in a given dimension. The other point is taken to be at position zero in that dimension.</param>
            <param name="mismatchDistanceConstant">A constant that is added to the distance where only one of the coordinates describes a position in a given dimension.
            This adds extra emphasis to distance when comparing coordinates that exist in different dimesions.</param>
        </member>
        <member name="M:SharpNeat.DistanceMetrics.ManhattanDistanceMetric.MeasureDistance(SharpNeat.Core.CoordinateVector,SharpNeat.Core.CoordinateVector,System.Double)">
            <summary>
            Tests if the distance between two positions is less than some threshold.
            
            A simple way of implementing this method would be to calculate the distance between the
            two coordinates and test if it is less than the threshold. However, that approach requires that all of the
            elements in both CoordinateVectors be fully compared. We can improve performance in the general case
            by testing if the threshold has been passed after each vector element comparison thus allowing an early exit
            from the method for many calls. Further to this, we can begin comparing from the ends of the vectors where 
            differences are most likely to occur.
            </summary>
        </member>
        <member name="M:SharpNeat.DistanceMetrics.ManhattanDistanceMetric.MeasureDistance(SharpNeat.Core.CoordinateVector,SharpNeat.Core.CoordinateVector)">
            <summary>
            Measures the distance between two positions.
            </summary>
        </member>
        <member name="M:SharpNeat.DistanceMetrics.ManhattanDistanceMetric.CalculateCentroid(System.Collections.Generic.IList{SharpNeat.Core.CoordinateVector})">
            <summary>
            Calculates the centroid for the given set of points.
            The centroid is a central position within a set of points that minimizes the sum of the squared distance
            between each of those points and the centroid. As such it can also be thought of as being an exemplar 
            for a set of points.
            
            The centroid calculation is dependent on the distance metric, hence this method is defined on IDistanceMetric.
            For some distance metrics the centroid may not be a unique point, in those cases one of the possible centroids
            is returned.
            
            A centroid is used in k-means clustering to define the center of a cluster.
            </summary>
        </member>
        <member name="M:SharpNeat.DistanceMetrics.ManhattanDistanceMetric.CalculateCentroidParallel(System.Collections.Generic.IList{SharpNeat.Core.CoordinateVector})">
            <summary>
            Parallelized version of CalculateCentroid().
            </summary>
        </member>
        <member name="T:SharpNeat.Decoders.HyperNeat.NodeSetMapping">
            <summary>
            Describes a mapping between nodesets.
            Packages an INodeSetMappingFunction with indexes into a list of node sets that identify the source
            and target nodesets for the mapping. 
            </summary>
        </member>
        <member name="M:SharpNeat.Decoders.HyperNeat.NodeSetMapping.#ctor(System.Int32,System.Int32,SharpNeat.Decoders.HyperNeat.INodeSetMappingFunction)">
            <summary>
            Constructs with the provided source and target nodeset indexes and mapping function to apply between those sets.
            </summary>
        </member>
        <member name="M:SharpNeat.Decoders.HyperNeat.NodeSetMapping.GenerateConnections(System.Collections.Generic.List{SharpNeat.Decoders.HyperNeat.SubstrateNodeSet})">
            <summary>
            Generates the connections defined by the mapping.
            </summary>
        </member>
        <member name="M:SharpNeat.Decoders.HyperNeat.NodeSetMapping.GetConnectionCountHint(System.Collections.Generic.List{SharpNeat.Decoders.HyperNeat.SubstrateNodeSet})">
            <summary>
            Returns an estimate/hint for the number of connections that would be created by the mapping.
            </summary>
        </member>
        <member name="M:SharpNeat.Decoders.HyperNeat.NodeSetMapping.Create(System.Int32,System.Int32,SharpNeat.Decoders.HyperNeat.INodeSetMappingFunction)">
            <summary>
            Creates a NodeSet from the provided source and target nodeset indexes and mapping function.
            </summary>
        </member>
        <member name="M:SharpNeat.Decoders.HyperNeat.NodeSetMapping.Create(System.Int32,System.Int32,System.Nullable{System.Double})">
            <summary>
            Creates a NodeSet from the provided source and target nodeset indexes and maximum connection distance for mappings/connections.
            </summary>
        </member>
        <member name="M:SharpNeat.Decoders.HyperNeat.NodeSetMapping.Create(System.Int32,System.Int32,System.Nullable{System.Double},System.Boolean)">
            <summary>
            Creates a NodeSet from the provided source and target nodeset indexes, maximum connection distance for mappings/connections and 
            a flag defining if local recurrent conenctions should be created when mapping between nodes in the same nodeset.
            </summary>
        </member>
        <member name="P:SharpNeat.Decoders.HyperNeat.NodeSetMapping.SourceNodeSetIdx">
            <summary>
            Gets the index of the source nodeset in some list of nodesets.
            </summary>
        </member>
        <member name="P:SharpNeat.Decoders.HyperNeat.NodeSetMapping.TargetNodeSetIdx">
            <summary>
            Gets the index of the target nodeset in some list of nodesets.
            </summary>
        </member>
        <member name="P:SharpNeat.Decoders.HyperNeat.NodeSetMapping.MappingFunction">
            <summary>
            Gets the mapping function to apply between the source and target nodesets.
            </summary>
        </member>
        <member name="T:SharpNeat.Core.FitnessInfo">
            <summary>
            Wrapper struct for fitness values.
            </summary>
        </member>
        <member name="F:SharpNeat.Core.FitnessInfo.Zero">
            <summary>
            Precosntructed FitnessInfo for commen case of representing zero fitness.
            </summary>
        </member>
        <member name="F:SharpNeat.Core.FitnessInfo._fitness">
            <summary>
            Fitness score.
            </summary>
        </member>
        <member name="F:SharpNeat.Core.FitnessInfo._alternativeFitness">
            <summary>
            Alternative fitness score. This value is provided to allow evaulators to report a number that is 
            more meaningful to humans, it is not used by the evolutionary algorithm in any way. The idea here is that fitness
            functions often apply complex traformations to one or more underlying fitness values to obtain a value with a number 
            of attributes that are desirable in fitenss functions (e.g. smooth fitness landscape). In applying those transformations
            the end fitness value can become hard to interpret directly, as such this value can be used to provide some meaningful
            underlying fitness value.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.FitnessInfo.#ctor(System.Double,System.Double)">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="T:SharpNeat.Genomes.Neat.ConnectionGeneList">
            <summary>
            Represents a sorted list of ConnectionGene objects. The sorting of the items is done on request
            rather than being strictly enforced at all times (e.g. as part of adding and removing genes). This
            approach is currently more convenient for use in some of the routines that work with NEAT genomes.
            
            Because we are not using a strictly sorted list such as the generic class SortedList[K,V] a customised 
            BinarySearch() method is provided for fast lookup of items if the list is known to be sorted. If the list is
            not sorted then the BinarySearch method's behaviour is undefined. This is potentially a source of bugs 
            and thus this class should probably migrate to SortedList[K,V] or be modified to ensure items are sorted 
            prior to a binary search.
            
            Sort order is with respect to connection gene innovation ID.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.ConnectionGeneList.#ctor">
            <summary>
            Construct an empty list.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.ConnectionGeneList.#ctor(System.Int32)">
            <summary>
            Construct an empty list with the specified capacity.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.ConnectionGeneList.#ctor(System.Collections.Generic.ICollection{SharpNeat.Genomes.Neat.ConnectionGene})">
            <summary>
            Copy constructor. The newly allocated list has a capacity 2 larger than copyFrom
            allowing addition mutations to occur without reallocation of memory.
            Note that a single add node mutation adds two connections and a single
            add connection mutation adds one.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.ConnectionGeneList.InsertIntoPosition(SharpNeat.Genomes.Neat.ConnectionGene)">
            <summary>
            Inserts a ConnectionGene into its correct (sorted) location within the gene list.
            Normally connection genes can safely be assumed to have a new Innovation ID higher
            than all existing IDs, and so we can just call Add().
            This routine handles genes with older IDs that need placing correctly.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.ConnectionGeneList.Remove(System.UInt32)">
            <summary>
            Remove the connection gene with the specified innovation ID.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.ConnectionGeneList.SortByInnovationId">
            <summary>
            Sort connection genes into ascending order by their innovation IDs.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.ConnectionGeneList.BinarySearch(System.UInt32)">
            <summary>
            Obtain the index of the gene with the specified innovation ID by performing a binary search.
            Binary search is fast and can be performed so long as we know the genes are sorted by innovation ID.
            If the genes are not sorted then the behaviour of this method is undefined.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.ConnectionGeneList.ResetIsMutatedFlags">
            <summary>
            Resets the IsMutated flag on all ConnectionGenes in the list.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.ConnectionGeneList.IsSorted">
            <summary>
            For debug purposes only. Don't call this method in normal circumstances as it is an
            expensive O(n) operation.
            </summary>
        </member>
        <member name="T:SharpNeat.DistanceMetrics.DistanceMetricUtils">
            <summary>
            Static helper methods for distance metrics.
            </summary>
        </member>
        <member name="M:SharpNeat.DistanceMetrics.DistanceMetricUtils.CalculateCentroid(SharpNeat.Core.IDistanceMetric,System.Collections.Generic.IList{SharpNeat.Core.CoordinateVector})">
            <summary>
            Calculates a centroid by comparing each coordinate with every other coordinate. The coord with the lowest 
            average distance from all other coords is the most central coord (the centroid).
            This method uses an inefficient N*N comparison of coords to find a centroid. It is provided only as a last
            resort for distance metrics for which no means exist to calculate a centroid more directly.
            </summary>
        </member>
        <member name="M:SharpNeat.DistanceMetrics.DistanceMetricUtils.CalculateMeanDistanceFromCoords(SharpNeat.Core.IDistanceMetric,System.Collections.Generic.IList{SharpNeat.Core.CoordinateVector},System.Int32)">
            <summary>
            Calculate the mean distance of the specified coord from all of the other coords using
            the provided distance metric.
            </summary>
            <param name="distanceMetric">The distance metric.</param>
            <param name="coordList">The list of coordinatres.</param>
            <param name="idx">The index of the coordinate to measure distance to.</param>
        </member>
        <member name="T:SharpNeat.Core.SelectiveGenomeListEvaluator`1">
            <summary>
            An IGenomeListEvaluator that wraps another IGenomeListEvaluator and filters/selects
            the genomes that are to be passed to the wrapped evaluator based on some predicate/test.
            
            This class supports evaluation schemes whereby not all genomes in a population are evaluated
            on each generation. E.g. if we wish to evaluate a genome2 that persists between generations 
            (i.e. elite genomes) just once (deterministic fitness score), or every N generations.
            
            A typical use would be to wrap SimpleGenomeListEvaulator or ParallelGenomeListEvaluator. 
            
            Genomes that skip evaluation have their EvaluationInfo.EvaluationPassCount property 
            incremented.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.SelectiveGenomeListEvaluator`1.#ctor(SharpNeat.Core.IGenomeListEvaluator{`0},System.Predicate{`0})">
            <summary>
            Construct with the provided IGenomeDecoder and IPhenomeEvaluator.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.SelectiveGenomeListEvaluator`1.Evaluate(System.Collections.Generic.IList{`0})">
            <summary>
            Evaluates a list of genomes. Here we select the genomes to be evaluated before invoking
            _innerEvaluator to evaluate them.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.SelectiveGenomeListEvaluator`1.Reset">
            <summary>
            Reset the internal state of the evaluation scheme if any exists.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.SelectiveGenomeListEvaluator`1.CreatePredicate_OnceOnly">
            <summary>
            Test that selects genomes that have never been evaluated.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.SelectiveGenomeListEvaluator`1.CreatePredicate_PeriodicReevaluation(System.Int32)">
            <summary>
            Selects genomes for evaluation every N attempts/generations.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.SelectiveGenomeListEvaluator`1.EvaluationCount">
            <summary>
            Gets the total number of individual genome2 evaluations that have been performed by this evaluator.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.SelectiveGenomeListEvaluator`1.StopConditionSatisfied">
            <summary>
            Gets a value indicating whether some goal fitness has been achieved and that
            the the evolutionary algorithm/search should stop. This property's value can remain false
            to allow the algorithm to run indefinitely.
            </summary>
        </member>
        <member name="T:SharpNeat.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:SharpNeat.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:SharpNeat.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="T:SharpNeat.Genomes.Neat.CorrelationItem">
            <summary>
            A single comparison item resulting from the comparison of two genomes. If the CorrelationItemType
            is Match then both connection gene properties will be non-null, otherwise one of them will be null 
            and and the other will hold a reference to a disjoint or excess connection gene.
            
            Note. We generally only compare connection genes when comparing genomes. Connection genes along with
            their innovation IDs actually represent the complete network topology (and of course the connection weights).
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.CorrelationItem.#ctor(SharpNeat.Genomes.Neat.CorrelationItemType,SharpNeat.Genomes.Neat.ConnectionGene,SharpNeat.Genomes.Neat.ConnectionGene)">
            <summary>
            Constructs a new CorrelationItem.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.CorrelationItem.CorrelationItemType">
            <summary>
            Gets the CorrelationItemType.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.CorrelationItem.ConnectionGene1">
            <summary>
            Gets the corresponding connection gene from comparison genome2 1.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.CorrelationItem.ConnectionGene2">
            <summary>
            Gets the corresponding connection gene from comparison genome2 2.
            </summary>
        </member>
        <member name="T:SharpNeat.SharpNeatException">
            <summary>
            General purpose exception class for use within SharpNeat.
            </summary>
        </member>
        <member name="M:SharpNeat.SharpNeatException.#ctor">
            <summary>
            Initializes a new instance of the SharpNeatException class.
            </summary>
        </member>
        <member name="M:SharpNeat.SharpNeatException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the SharpNeatException class with a specified error message. 
            </summary>
        </member>
        <member name="M:SharpNeat.SharpNeatException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the SharpNeatException class with a specified error message 
            and a reference to the inner exception that is the cause of this exception. 
            </summary>
        </member>
        <member name="T:SharpNeat.Network.NullFn">
            <summary>
            Null activation function. Returns zero regardless of input.
            </summary>
        </member>
        <member name="F:SharpNeat.Network.NullFn.__DefaultInstance">
            <summary>
            Default instance provided as a public static field.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.NullFn.Calculate(System.Double)">
            <summary>
            Calculates the output value for the specified input value.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.NullFn.Calculate(System.Single)">
            <summary>
            Calculates the output value for the specified input value with float/single precision.
            This single precision overload of Calculate() will be used in neural network code 
            that has been specifically written to use floats instead of doubles.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.NullFn.FunctionId">
            <summary>
            Gets the unique ID of the function. Stored in network XML to identify which function a network or neuron 
            is using.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.NullFn.FunctionString">
            <summary>
            Gets a human readable string representation of the function. E.g 'y=1/x'.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.NullFn.FunctionDescription">
            <summary>
            Gets a human readable verbose description of the activation function.
            </summary>
        </member>
        <member name="T:SharpNeat.Phenomes.NeuralNets.FastConnection">
            <summary>
            Working data struct for use in FastRecurrentNetwork and sub-classes.
            Represents a single connection - its weigth and source/target neurons.
            </summary>
        </member>
        <member name="T:SharpNeat.Network.InverseAbsoluteSigmoid">
            <summary>
            A sigmoid curve produced from the simple and therefore fast arithmetic operations abs,
            divide and multiply. The curve is designed to match the SteepenedSigmoid activation function 
            as closely as possible.
            </summary>
        </member>
        <member name="F:SharpNeat.Network.InverseAbsoluteSigmoid.__DefaultInstance">
            <summary>
            Default instance provided as a public static field.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.InverseAbsoluteSigmoid.Calculate(System.Double)">
            <summary>
            Calculates the output value for the specified input value.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.InverseAbsoluteSigmoid.Calculate(System.Single)">
            <summary>
            Calculates the output value for the specified input value with float/single precision.
            This single precision overload of Calculate() will be used in neural network code 
            that has been specifically written to use floats instead of doubles.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.InverseAbsoluteSigmoid.FunctionId">
            <summary>
            Gets the unique ID of the function. Stored in network XML to identify which function a network or neuron 
            is using.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.InverseAbsoluteSigmoid.FunctionString">
            <summary>
            Gets a human readable string representation of the function. E.g 'y=1/x'.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.InverseAbsoluteSigmoid.FunctionDescription">
            <summary>
            Gets a human readable verbose description of the activation function.
            </summary>
        </member>
        <member name="T:SharpNeat.Network.Absolute">
            <summary>
            Absolute value (magnitude) activation function.
            </summary>
        </member>
        <member name="F:SharpNeat.Network.Absolute.__DefaultInstance">
            <summary>
            Default instance provided as a public static field.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.Absolute.Calculate(System.Double)">
            <summary>
            Calculates the output value for the specified input value.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.Absolute.Calculate(System.Single)">
            <summary>
            Calculates the output value for the specified input value with float/single precision.
            This single precision overload of Calculate() will be used in neural network code 
            that has been specifically written to use floats instead of doubles.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.Absolute.FunctionId">
            <summary>
            Gets the unique ID of the function. Stored in network XML to identify which function a network or neuron 
            is using.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.Absolute.FunctionString">
            <summary>
            Gets a human readable string representation of the function. E.g 'y=1/x'.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.Absolute.FunctionDescription">
            <summary>
            Gets a human readable verbose description of the activation function.
            </summary>
        </member>
        <member name="T:SharpNeat.Network.NetworkNode">
            <summary>
            Concrete implementation of an INetworkNode.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.NetworkNode.#ctor(System.UInt32,SharpNeat.Network.NodeType,System.Int32)">
            <summary>
            Constructs with the provided node ID, type and activation function ID.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.NetworkNode.Id">
            <summary>
            Gets the node's unique ID.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.NetworkNode.NodeType">
            <summary>
            Gets the node's type.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.NetworkNode.ActivationFnId">
            <summary>
            Gets the node's activation function ID. This is an ID into an IActivationFunctionLibrary
            associated with the network as a whole.
            </summary>
        </member>
        <member name="T:SharpNeat.Network.NetworkDefinition">
            <summary>
            Concrete implementation of INetworkDefinition.
            This class represents network definitions independently of any other requirements, e.g.
            a NeatGenome is also an INetworkDefinition but with additional baggage. This class
            is useful for representing network definitions, e.g. when creating a network instance from 
            a HyperNEAT substrate.
            </summary>
        </member>
        <member name="T:SharpNeat.Network.INetworkDefinition">
            <summary>
            Abstracted representation of a network definition.
            This interface and the related types INodeList, IConnectionList, INetworkNode,
            INetworkConnection, etc, allow networks to be described abstractly. 
            
            One significant use of this class is in the decoding of genome2 classes into concrete 
            network instances; The decode methods can be written to operate on INetworkDefinition
            rather than specific genome2 types.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.INetworkDefinition.InputNodeCount">
            <summary>
            Gets the number of input nodes. This does not include the bias node which is always present.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.INetworkDefinition.OutputNodeCount">
            <summary>
            Gets the number of output nodes.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.INetworkDefinition.ActivationFnLibrary">
            <summary>
            Gets the network's activation function library. The activation function at each node is 
            represented by an integer ID, which refers to a function in this activation function library.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.INetworkDefinition.NodeList">
            <summary>
            Gets the list of network nodes.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.INetworkDefinition.ConnectionList">
            <summary>
            Gets the list of network connections.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.NetworkDefinition.#ctor(System.Int32,System.Int32,SharpNeat.Network.IActivationFunctionLibrary,System.Int32,System.Int32)">
            <summary>
            Constructs with the provided input/output node count, activation function library and
            initial capacities for the node and connection lists.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.NetworkDefinition.#ctor(System.Int32,System.Int32,SharpNeat.Network.IActivationFunctionLibrary,SharpNeat.Network.NodeList,SharpNeat.Network.ConnectionList)">
            <summary>
            Constructs with the provided input/output node count, activation function library, 
            node and connection lists.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.NetworkDefinition.PerformIntegrityCheck">
            <summary>
            Performs an integrity check on the network definition.
            Returns true if OK.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.NetworkDefinition.InputNodeCount">
            <summary>
            Gets the number of input nodes. This does not include the bias node which is always present.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.NetworkDefinition.OutputNodeCount">
            <summary>
            Gets the number of output nodes.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.NetworkDefinition.ActivationFnLibrary">
            <summary>
            Gets the network's activation function library. The activation function at each node is represented
            by an integer ID, which refers to a function in this library.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.NetworkDefinition.NodeList">
            <summary>
            Gets the list of network nodes.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.NetworkDefinition.ConnectionList">
            <summary>
            Gets the list of network connections.
            </summary>
        </member>
        <member name="T:SharpNeat.Genomes.Neat.ConnectionMutationInfoList">
            <summary>
            Represents a list of ConnectionMutationInfo objects. 
            
            Also hold a RouletteWheelLayout built from the activation probability values of the
            contained ConnectionMutationInfo objects. This can be used to select a mutation type
            to use within the NeatGenome mutation routines.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.ConnectionMutationInfoList.#ctor">
            <summary>
            Constructs an empty list.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.ConnectionMutationInfoList.#ctor(System.Int32)">
            <summary>
            Constructs an empty list.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.ConnectionMutationInfoList.#ctor(System.Collections.Generic.ICollection{SharpNeat.Genomes.Neat.ConnectionMutationInfo})">
            <summary>
            Copy constructor. We make individual copies of the list items (deep copy), rather than
            only copying the item object references.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.ConnectionMutationInfoList.Initialize">
            <summary>
            Initialize the list. Call this after all items have been aded to the list. This
            creates a RouletteWheelLayout based upon the activation probability of each item 
            in the list.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.ConnectionMutationInfoList.GetRandomItem(SharpNeat.Utility.FastRandom)">
            <summary>
            Gets one of the ConnectionMutationInfo items at random based upon the ActivationProbability 
            of the contained items.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.ConnectionMutationInfoList.RouletteWheelLayout">
            <summary>
            Gets the RouletteWheelLayout for the items in the list. This is based upon the activation 
            probability of each item in the list at the time Initialise was called.
            </summary>
        </member>
        <member name="T:SharpNeat.Network.ActivationFunctionInfo">
            <summary>
            Represents a single item in an IActivationFunctionLibrary.
            The item represents an IActivationFunction and its ID and selection probability within
            the owning IActivationFunctionLibrary.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.ActivationFunctionInfo.#ctor(System.Int32,System.Double,SharpNeat.Network.IActivationFunction)">
            <summary>
            Construct with the provided id, selection probability and activation function.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.ActivationFunctionInfo.Id">
            <summary>
            Gets the integer ID assigned to the function in the owning function library.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.ActivationFunctionInfo.SelectionProbability">
            <summary>
            Gets the selection probability of the item.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.ActivationFunctionInfo.ActivationFunction">
            <summary>
            Gets the activation function object.
            </summary>
        </member>
        <member name="T:SharpNeat.Decoders.NetworkActivationScheme">
            <summary>
            Represents network activation schemes. E.g. fixed number of activation timesteps
            or activation until the network becomes 'relaxed'. Relaxed here means that no node's
            output value changed by more than some threshold value.
            </summary>
        </member>
        <member name="M:SharpNeat.Decoders.NetworkActivationScheme.#ctor(System.Int32)">
            <summary>
            Construct a scheme with a fixed number of activation timesteps.
            </summary>
        </member>
        <member name="M:SharpNeat.Decoders.NetworkActivationScheme.#ctor(System.Int32,System.Boolean)">
            <summary>
            Construct a scheme with a fixed number of activation timesteps.
            'fastFlag' indicates if a fast network implementation should be used.
            </summary>
        </member>
        <member name="M:SharpNeat.Decoders.NetworkActivationScheme.#ctor(System.Double,System.Int32)">
            <summary>
            Construct a relaxing network activation scheme.
            </summary>
        </member>
        <member name="M:SharpNeat.Decoders.NetworkActivationScheme.#ctor(System.Double,System.Int32,System.Boolean)">
            <summary>
            Construct a relaxing network activation scheme.
            'fastFlag' indicates if a fast network implementation should be used.
            </summary>
        </member>
        <member name="P:SharpNeat.Decoders.NetworkActivationScheme.RelaxingActivation">
            <summary>
            Gets a value indicating whether the scheme is a relaxing activation scheme.
            </summary>
        </member>
        <member name="P:SharpNeat.Decoders.NetworkActivationScheme.TimestepsPerActivation">
            <summary>
            Gets a fixed number of activation timesteps.
            Non-relaxing activation scheme.
            </summary>
        </member>
        <member name="P:SharpNeat.Decoders.NetworkActivationScheme.SignalDeltaThreshold">
            <summary>
            Gets a maximum signal delta threshold used to determine if a network is relaxed.
            Relaxing activation scheme.
            </summary>
        </member>
        <member name="P:SharpNeat.Decoders.NetworkActivationScheme.MaxTimesteps">
            <summary>
            Gets the maximum number of activation timesteps before stopping.
            Relaxing activation scheme. 
            </summary>
        </member>
        <member name="P:SharpNeat.Decoders.NetworkActivationScheme.FastFlag">
            <summary>
            Gets a value indicating whether a fast version of the network should be created when decoding.
            </summary>
        </member>
        <member name="T:SharpNeat.Decoders.HyperNeat.SubstrateConnection">
            <summary>
            Represents a connection between two nodes in a HyperNEAT substrate.
            The node positions are represented as arrays of numbers so as not to limit the number of
            dimensions that positions (and therefore substrates) can be defined within.
            </summary>
        </member>
        <member name="F:SharpNeat.Decoders.HyperNeat.SubstrateConnection._srcNode">
            <summary>The source node.</summary>
        </member>
        <member name="F:SharpNeat.Decoders.HyperNeat.SubstrateConnection._tgtNode">
            <summary>The target node.</summary>
        </member>
        <member name="M:SharpNeat.Decoders.HyperNeat.SubstrateConnection.#ctor(SharpNeat.Decoders.HyperNeat.SubstrateNode,SharpNeat.Decoders.HyperNeat.SubstrateNode)">
            <summary>
            Constructs with the specified source and target substrate nodes.
            </summary>
        </member>
        <member name="T:SharpNeat.SpeciationStrategies.ParallelKMeansClusteringStrategy`1">
            <summary>
            An ISpeciationStrategy that speciates genomes using the k-means clustering method.
            k-means requires a distance metric and as such this class requires am IDistanceMetric to be provided at 
            construction time. Different distance metrics can be used including NeatDistanceMetric which is 
            equivalent to the metric used in the standard NEAT method albeit with a different clustering/speciation
            algorithm (Standard NEAT does not use k-means).
            </summary>
            <typeparam name="TGenome">The genome2 type to apply clustering to.</typeparam>
        </member>
        <member name="M:SharpNeat.SpeciationStrategies.ParallelKMeansClusteringStrategy`1.#ctor(SharpNeat.Core.IDistanceMetric)">
            <summary>
            Constructor that accepts an IDistanceMetric to be used for the k-means method.
            </summary>
        </member>
        <member name="M:SharpNeat.SpeciationStrategies.ParallelKMeansClusteringStrategy`1.#ctor(SharpNeat.Core.IDistanceMetric,System.Threading.Tasks.ParallelOptions)">
            <summary>
            Constructor that accepts an IDistanceMetric to be used for the k-means method and ParallelOptions. 
            </summary>
        </member>
        <member name="M:SharpNeat.SpeciationStrategies.ParallelKMeansClusteringStrategy`1.InitializeSpeciation(System.Collections.Generic.IList{`0},System.Int32)">
            <summary>
            Speciates the genomes in genomeList into the number of species specified by specieCount
            and returns a newly constructed list of Specie objects containing the speciated genomes.
            </summary>
        </member>
        <member name="M:SharpNeat.SpeciationStrategies.ParallelKMeansClusteringStrategy`1.SpeciateGenomes(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{SharpNeat.Core.Specie{`0}})">
            <summary>
            Speciates the genomes in genomeList into the provided specieList. It is assumed that
            the genomeList represents all of the required genomes and that the species are currently empty.
            
            This method can be used for initialization or completely respeciating an existing genome2 population.
            </summary>
        </member>
        <member name="M:SharpNeat.SpeciationStrategies.ParallelKMeansClusteringStrategy`1.SpeciateOffspring(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{SharpNeat.Core.Specie{`0}})">
            <summary>
            Speciates the offspring genomes in offspringList into the provided specieList. In contrast to
            SpeciateGenomes() offspringList is taken to be a list of new genomes (offspring) that should be 
            added to existing species. That is, the species contain genomes that are not in offspringList
            that we wish to keep; typically these would be elite genomes that are the parents of the
            offspring.
            </summary>
        </member>
        <member name="M:SharpNeat.SpeciationStrategies.ParallelKMeansClusteringStrategy`1.SpeciateUntilConvergence(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{SharpNeat.Core.Specie{`0}})">
            <summary>
            Perform the main k-means loop until no genome2 reallocations occur or some maximum number of loops
            has been performed. Theoretically a small number of reallocations may occur for a great many loops 
            therefore we require the additional max loops threshold exit strategy - the clusters should be pretty
            stable and well defined after a few loops even if the the algorithm hasn't converged completely.
            </summary>
        </member>
        <member name="M:SharpNeat.SpeciationStrategies.ParallelKMeansClusteringStrategy`1.CalculateSpecieCentroid(SharpNeat.Core.Specie{`0})">
            <summary>
            Recalculate the specie centroid based on the genomes currently in the specie.
            </summary>
        </member>
        <member name="M:SharpNeat.SpeciationStrategies.ParallelKMeansClusteringStrategy`1.GetGenomesByDistanceFromSpecie(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{SharpNeat.Core.Specie{`0}})">
            <summary>
            Gets an array of all genomes ordered by their distance from their current specie.
            </summary>
        </member>
        <member name="M:SharpNeat.SpeciationStrategies.ParallelKMeansClusteringStrategy`1.FindClosestSpecie(`0,System.Collections.Generic.IList{SharpNeat.Core.Specie{`0}})">
            <summary>
            Find the specie that a genome2 is closest to as determined by the distance metric.
            </summary>
        </member>
        <member name="T:SharpNeat.Phenomes.NeuralNets.Connection">
            <summary>
            Represents a single connection between two neurons in a RecurrentNetwork.
            </summary>
        </member>
        <member name="M:SharpNeat.Phenomes.NeuralNets.Connection.#ctor(SharpNeat.Phenomes.NeuralNets.Neuron,SharpNeat.Phenomes.NeuralNets.Neuron,System.Double)">
            <summary>
            Constructs a Connection with the provided source and target neurons, and connection weight. 
            </summary>
        </member>
        <member name="P:SharpNeat.Phenomes.NeuralNets.Connection.SourceNeuron">
            <summary>
            Gets the connection's source neuron.
            </summary>
        </member>
        <member name="P:SharpNeat.Phenomes.NeuralNets.Connection.TargetNeuron">
            <summary>
            Gets the connection's target neuron.
            </summary>
        </member>
        <member name="P:SharpNeat.Phenomes.NeuralNets.Connection.Weight">
            <summary>
            Gets the connection's weight.
            </summary>
        </member>
        <member name="P:SharpNeat.Phenomes.NeuralNets.Connection.OutputValue">
            <summary>
            Gets or sets the connection's output value.
            </summary>
        </member>
        <member name="T:SharpNeat.Phenomes.NeuralNets.Neuron">
            <summary>
            Represents a single neuron in a RecurrentNetwork.
            </summary>
        </member>
        <member name="M:SharpNeat.Phenomes.NeuralNets.Neuron.#ctor(System.UInt32,SharpNeat.Network.NodeType,SharpNeat.Network.IActivationFunction)">
            <summary>
            Constructs a Neuron with the provided ID, type and activation function.
            </summary>
        </member>
        <member name="P:SharpNeat.Phenomes.NeuralNets.Neuron.Id">
            <summary>
            Gets the neuron's ID.
            </summary>
        </member>
        <member name="P:SharpNeat.Phenomes.NeuralNets.Neuron.NeuronType">
            <summary>
            Gets the neuron's type.
            </summary>
        </member>
        <member name="P:SharpNeat.Phenomes.NeuralNets.Neuron.ActivationFunction">
            <summary>
            Gets the neuron's activation function.
            </summary>
        </member>
        <member name="P:SharpNeat.Phenomes.NeuralNets.Neuron.InputValue">
            <summary>
            Gets or sets the neuron's current input value.
            </summary>
        </member>
        <member name="P:SharpNeat.Phenomes.NeuralNets.Neuron.OutputValue">
            <summary>
            Gets or sets the neuron's current output value. This is set to a fixed value for bias neurons.
            </summary>
        </member>
        <member name="T:SharpNeat.Network.PlainSigmoid">
            <summary>
            Simple sigmoid activation function.
            </summary>
        </member>
        <member name="F:SharpNeat.Network.PlainSigmoid.__DefaultInstance">
            <summary>
            Default instance provided as a public static field.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.PlainSigmoid.Calculate(System.Double)">
            <summary>
            Calculates the output value for the specified input value.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.PlainSigmoid.Calculate(System.Single)">
            <summary>
            Calculates the output value for the specified input value with float/single precision.
            This single precision overload of Calculate() will be used in neural network code 
            that has been specifically written to use floats instead of doubles.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.PlainSigmoid.FunctionId">
            <summary>
            Gets the unique ID of the function. Stored in network XML to identify which function a network or neuron 
            is using.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.PlainSigmoid.FunctionString">
            <summary>
            Gets a human readable string representation of the function. E.g 'y=1/x'.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.PlainSigmoid.FunctionDescription">
            <summary>
            Gets a human readable verbose description of the activation function.
            </summary>
        </member>
        <member name="T:SharpNeat.Network.NetworkXmlIO">
            <summary>
            Static class for reading and writing Network Definitions(s) to and from XML.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.NetworkXmlIO.SaveComplete(SharpNeat.Network.NetworkDefinition,System.Boolean)">
            <summary>
            Writes a single NetworkDefinition to XML within a containing 'Root' element and the activation function
            library that the genome2 is associated with.
            The XML is returned as a newly created XmlDocument.
            </summary>
            <param name="networkDef">The NetworkDefinition to save.</param>
            <param name="nodeFnIds">Indicates if node activation function IDs should be emitted. They are required
            for HyperNEAT genomes but not for NEAT.</param>
        </member>
        <member name="M:SharpNeat.Network.NetworkXmlIO.SaveComplete(System.Collections.Generic.IList{SharpNeat.Network.NetworkDefinition},System.Boolean)">
            <summary>
            Writes a list of NetworkDefinition(s) to XML within a containing 'Root' element and the activation
            function library that the genomes are associated with.
            The XML is returned as a newly created XmlDocument.
            </summary>
            <param name="networkDefList">List of genomes to write as XML.</param>
            <param name="nodeFnIds">Indicates if node activation function IDs should be emitted. They are required
            for HyperNEAT genomes but not for NEAT.</param>
        </member>
        <member name="M:SharpNeat.Network.NetworkXmlIO.Save(SharpNeat.Network.NetworkDefinition,System.Boolean)">
            <summary>
            Writes a single NetworkDefinition to XML.
            The XML is returned as a newly created XmlDocument.
            </summary>
            <param name="networkDef">The genome2 to save.</param>
            <param name="nodeFnIds">Indicates if node activation function IDs should be emitted. They are required
            for HyperNEAT genomes but not for NEAT.</param>
        </member>
        <member name="M:SharpNeat.Network.NetworkXmlIO.LoadCompleteGenomeList(System.Xml.XmlNode,System.Boolean)">
            <summary>
            Reads a list of NetworkDefinition(s) from XML that has a containing 'Root' element. The root element 
            also contains the activation function library that the network definitions are associated with.
            </summary>
            <param name="xmlNode">The XmlNode to read from. This can be an XmlDocument or XmlElement.</param>
            <param name="nodeFnIds">Indicates if node activation function IDs should be read. If false then 
            all node activation function IDs default to 0.</param>
        </member>
        <member name="M:SharpNeat.Network.NetworkXmlIO.ReadGenome(System.Xml.XmlNode,SharpNeat.Network.IActivationFunctionLibrary,System.Boolean)">
            <summary>
            Reads a NetworkDefinition from XML.
            </summary>
            <param name="xmlNode">The XmlNode to read from. This can be an XmlDocument or XmlElement.</param>
            <param name="activationFnLib">The activation function library used to decode node activation function IDs.</param>
            <param name="nodeFnIds">Indicates if node activation function IDs should be read. They are required
            for HyperNEAT genomes but not for NEAT</param>
        </member>
        <member name="M:SharpNeat.Network.NetworkXmlIO.WriteComplete(System.Xml.XmlWriter,System.Collections.Generic.IList{SharpNeat.Network.NetworkDefinition},System.Boolean)">
            <summary>
            Writes a list of INetworkDefinition(s) to XML within a containing 'Root' element and the activation
            function library that the genomes are associated with.
            </summary>
            <param name="xw">XmlWriter to write XML to.</param>
            <param name="networkDefList">List of network definitions to write as XML.</param>
            <param name="nodeFnIds">Indicates if node activation function IDs should be emitted. They are required
            for HyperNEAT genomes but not for NEAT.</param>
        </member>
        <member name="M:SharpNeat.Network.NetworkXmlIO.WriteComplete(System.Xml.XmlWriter,System.Collections.Generic.IList{SharpNeat.Network.INetworkDefinition},System.Boolean)">
            <summary>
            Writes a list of INetworkDefinition(s) to XML within a containing 'Root' element and the activation
            function library that the genomes are associated with.
            </summary>
            <param name="xw">XmlWriter to write XML to.</param>
            <param name="networkDefList">List of network definitions to write as XML.</param>
            <param name="nodeFnIds">Indicates if node activation function IDs should be emitted. They are required
            for HyperNEAT genomes but not for NEAT.</param>
        </member>
        <member name="M:SharpNeat.Network.NetworkXmlIO.WriteComplete(System.Xml.XmlWriter,SharpNeat.Network.INetworkDefinition,System.Boolean)">
            <summary>
            Writes a single INetworkDefinition to XML within a containing 'Root' element and the activation
            function library that the genome2 is associated with.
            </summary>
            <param name="xw">XmlWriter to write XML to.</param>
            <param name="networkDef">Network definition to write as XML.</param>
            <param name="nodeFnIds">Indicates if node activation function IDs should be emitted. They are required
            for HyperNEAT genomes but not for NEAT.</param>
        </member>
        <member name="M:SharpNeat.Network.NetworkXmlIO.Write(System.Xml.XmlWriter,SharpNeat.Network.INetworkDefinition,System.Boolean)">
            <summary>
            Writes an INetworkDefinition to XML.
            </summary>
            <param name="xw">XmlWriter to write XML to.</param>
            <param name="networkDef">Network definition to write as XML.</param>
            <param name="nodeFnIds">Indicates if node activation function IDs should be emitted. They are required
            for HyperNEAT genomes but not for NEAT.</param>
        </member>
        <member name="M:SharpNeat.Network.NetworkXmlIO.Write(System.Xml.XmlWriter,SharpNeat.Network.IActivationFunctionLibrary)">
            <summary>
            Writes an activation function library to XML. This links activation function names to the 
            integer IDs used by network nodes, which allows us emit just the ID for each node thus 
            resulting in XML that is more compact compared to emitting the activation function name for
            each node.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.NetworkXmlIO.ReadCompleteNetworkDefinitionList(System.Xml.XmlReader,System.Boolean)">
            <summary>
            Reads a list of NetworkDefinition(s) from XML that has a containing 'Root' element. The root 
            element also contains the activation function library that the genomes are associated with.
            </summary>
            <param name="xr">The XmlReader to read from.</param>
            <param name="nodeFnIds">Indicates if node activation function IDs should be read. They are required
            for HyperNEAT genomes but not NEAT</param>
        </member>
        <member name="M:SharpNeat.Network.NetworkXmlIO.ReadNetworkDefinition(System.Xml.XmlReader,SharpNeat.Network.IActivationFunctionLibrary,System.Boolean)">
            <summary>
            Reads a network definition from XML. 
            An activation function library is required to decode the function ID at each node, typically the
            library is stored alongside the network definition XML and will have already been read elsewhere and
            passed in here.
            </summary>
            <param name="xr">The XmlReader to read from.</param>
            <param name="activationFnLib">The activation function library used to decode node activation function IDs.</param>
            <param name="nodeFnIds">Indicates if node activation function IDs should be read. They are required
            for HyperNEAT genomes but not NEAT</param>
        </member>
        <member name="M:SharpNeat.Network.NetworkXmlIO.ReadActivationFunctionLibrary(System.Xml.XmlReader)">
            <summary>
            Reads an IActivationFunctionLibrary from the provided XmlReader.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.NetworkXmlIO.MoveToElement(System.Xml.XmlReader,System.Boolean,System.String)">
            <summary>
            Read from the XmlReader until we encounter an element. If the name doesn't match
            elemName then throw an exception, else return normally.
            
            </summary>
        </member>
        <member name="M:SharpNeat.Network.NetworkXmlIO.MoveToElement(System.Xml.XmlReader,System.Boolean)">
            <summary>
            Read from the XmlReader until we encounter an element. 
            Return the Local name of the element or null if no element was found before 
            the end of the input.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.NetworkXmlIO.ReadAttributeAsInt(System.Xml.XmlReader,System.String)">
            <summary>
            Read the named attribute and parse its string value as an integer.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.NetworkXmlIO.ReadAttributeAsUInt(System.Xml.XmlReader,System.String)">
            <summary>
            Read the named attribute and parse its string value as a uint.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.NetworkXmlIO.ReadAttributeAsDouble(System.Xml.XmlReader,System.String)">
            <summary>
            Read the named attribute and parse its string value as a double.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.NetworkXmlIO.ReadAttributeAsNodeType(System.Xml.XmlReader,System.String)">
            <summary>
            Read the named attribute and parse its string value as a NodeType.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.NetworkXmlIO.GetNodeType(System.String)">
            <summary>
            Gets the NodeType for the specified node type string.
            Note. we use our own type strings in place of Enum.ToString() to provide more compact XML.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.NetworkXmlIO.GetNodeTypeString(SharpNeat.Network.NodeType)">
            <summary>
            Gets the node type string for the specified NodeType.
            Note. we use our own type strings in place of Enum.ToString() to provide more compact XML.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.NetworkXmlIO.GetActivationFunction(System.String)">
            <summary>
            Gets an IActivationFunction from its short name.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.NetworkXmlIO.NormalizeSelectionProbabilities(System.Collections.Generic.IList{SharpNeat.Network.ActivationFunctionInfo})">
            <summary>
            Normalize the selection probabilities of the provided ActivationFunctionInfo items.
            </summary>
        </member>
        <member name="T:SharpNeat.Network.NetworkConnection">
            <summary>
            Concrete implementation of INetworkConnection.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.NetworkConnection.#ctor(System.UInt32,System.UInt32,System.Double)">
            <summary>
            Constructs with the provided source and target node IDs and weight.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.NetworkConnection.SourceNodeId">
            <summary>
            Gets the ID of the connection's source node.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.NetworkConnection.TargetNodeId">
            <summary>
            Gets the ID of the connection's target node.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.NetworkConnection.Weight">
            <summary>
            Gets the connection's weight.
            </summary>
        </member>
        <member name="T:SharpNeat.Decoders.FastRecurrentNetworkFactory">
            <summary>
            Static factory for creating RecurrentNetwork's from INetworkDefinition's.
            </summary>
        </member>
        <member name="M:SharpNeat.Decoders.FastRecurrentNetworkFactory.CreateFastRecurrentNetwork(SharpNeat.Network.INetworkDefinition,SharpNeat.Decoders.NetworkActivationScheme)">
            <summary>
            Creates a RecurrentNetwork from an INetworkDefinition.
            </summary>
        </member>
        <member name="T:SharpNeat.Core.UpdateMode">
            <summary>
            An enumeration of update schemes, e.g. Fire an update event the per some time duration or some number of generations.
            </summary>
        </member>
        <member name="F:SharpNeat.Core.UpdateMode.Timespan">
            <summary>
            Raise an update event at regular time intervals.
            </summary>
        </member>
        <member name="F:SharpNeat.Core.UpdateMode.Generational">
            <summary>
            Raise an update event at regular generation intervals. (Every N generations).
            </summary>
        </member>
        <member name="T:SharpNeat.Network.Gaussian">
            <summary>
            Gaussian activation function. Output range is 0 to 1, that is, the tails of the gaussian
            distribution curve tend towards 0 as abs(x) -> Infinity and the gaussian's peak is at y = 1.
            </summary>
        </member>
        <member name="F:SharpNeat.Network.Gaussian.__DefaultInstance">
            <summary>
            Default instance provided as a public static field.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.Gaussian.Calculate(System.Double)">
            <summary>
            Calculates the output value for the specified input value.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.Gaussian.Calculate(System.Single)">
            <summary>
            Calculates the output value for the specified input value with float/single precision.
            This single precision overload of Calculate() will be used in neural network code 
            that has been specifically written to use floats instead of doubles.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.Gaussian.FunctionId">
            <summary>
            Gets the unique ID of the function. Stored in network XML to identify which function a network or neuron 
            is using.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.Gaussian.FunctionString">
            <summary>
            Gets a human readable string representation of the function. E.g 'y=1/x'.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.Gaussian.FunctionDescription">
            <summary>
            Gets a human readable verbose description of the activation function.
            </summary>
        </member>
        <member name="T:SharpNeat.Network.ConnectionList">
            <summary>
            A concrete implementation of IConnectionList.
            Part of the INetworkDefinition type hierarchy.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.ConnectionList.#ctor">
            <summary>
            Constructs an empty list.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.ConnectionList.#ctor(System.Int32)">
            <summary>
            Constructs a list with the specified initial capacity.
            </summary>
        </member>
        <member name="T:SharpNeat.Decoders.HyperNeat.SubstrateNode">
            <summary>
            Represents a node within a HyperNEAT substrate.
            </summary>
        </member>
        <member name="F:SharpNeat.Decoders.HyperNeat.SubstrateNode._id">
            <summary>
            Node ID.
            </summary>
        </member>
        <member name="F:SharpNeat.Decoders.HyperNeat.SubstrateNode._position">
            <summary>
            The node's position coordinates on the substrate. The substrate dimensionality is not restricted.
            </summary>
        </member>
        <member name="M:SharpNeat.Decoders.HyperNeat.SubstrateNode.#ctor(System.UInt32,System.Double[])">
            <summary>
            Construct with the specified node ID and position coordinates.
            </summary>
        </member>
        <member name="T:SharpNeat.Decoders.HyperNeat.DefaultNodeSetMappingFunction">
            <summary>
            Defines a mapping between two node sets based on mapping all source nodes to all target nodes, but with an option to 
            omit mappings where the distance between source and target node is over some threshold. 
            
            In addition the same nodeset can be passed to the GenerateConnections() method as both source and targt. This allows 
            for creating connections between nodes within a layer. The optional max distance still applies and an additional boolean
            option indicates if the local recurrent conenction for each node (from its output back to its input) should be generated.
            </summary>
        </member>
        <member name="F:SharpNeat.Decoders.HyperNeat.DefaultNodeSetMappingFunction._maximumConnectionDistance">
            <summary>
            Maximum distance between connected nodes.
            If the distance between two nodes is less than this value then a mapping/connection is generated.
            </summary>
        </member>
        <member name="F:SharpNeat.Decoders.HyperNeat.DefaultNodeSetMappingFunction._maximumConnectionDistanceSquared">
            <summary>
            _maximumConnectionDistance value squared. This allows us to test connection lengths without having to take the 
            square root, which is much faster.
            </summary>
        </member>
        <member name="F:SharpNeat.Decoders.HyperNeat.DefaultNodeSetMappingFunction._allowLocalRecurrentConnections">
            <summary>
            If set this fag indicates that connections from a node's output back to its input are generated if the same
            nodeset is passed into the GenerateConnections() method as both the source and target nodeset.
            </summary>
        </member>
        <member name="F:SharpNeat.Decoders.HyperNeat.DefaultNodeSetMappingFunction._testNodePair">
            <summary>
            Delegate for testing whether a mapping/connection should be generated between the specified nodes.
            </summary>
        </member>
        <member name="M:SharpNeat.Decoders.HyperNeat.DefaultNodeSetMappingFunction.#ctor(System.Nullable{System.Double},System.Boolean)">
            <summary>
            Construct with the specified maximum connection distance (optional/nullable) and flag indicating if local recurrent 
            connections should be generated when generating connections within a single node set (same source and target nodeset).
            </summary>
        </member>
        <member name="M:SharpNeat.Decoders.HyperNeat.DefaultNodeSetMappingFunction.GenerateConnections(SharpNeat.Decoders.HyperNeat.SubstrateNodeSet,SharpNeat.Decoders.HyperNeat.SubstrateNodeSet)">
            <summary>
            Returns an IEnumerable that yields the mappings/connections defined by the mapping function (from the source nodes to
            the target nodes) as a sequence. The alternative of returning a list would require a very long list in extreme scenarios; 
            this approach minimizes down memory usage.
            </summary>
        </member>
        <member name="M:SharpNeat.Decoders.HyperNeat.DefaultNodeSetMappingFunction.GetConnectionCountHint(SharpNeat.Decoders.HyperNeat.SubstrateNodeSet,SharpNeat.Decoders.HyperNeat.SubstrateNodeSet)">
            <summary>
            Returns an estimate/hint for the number of connections that would be created between the provided source and target node sets.
            </summary>
        </member>
        <member name="M:SharpNeat.Decoders.HyperNeat.DefaultNodeSetMappingFunction.CalcDistanceSquared(System.Double[],System.Double[])">
            <summary>
            Calulcate the Euclidean distance between two points in n-dimensions.
            </summary>
        </member>
        <member name="T:SharpNeat.Decoders.HyperNeat.DefaultNodeSetMappingFunction.TestNodePair">
            <summary>
            Definition of a delegate for testing whether a mapping/connection should be generated between the specified nodes.
            </summary>
        </member>
        <member name="T:SharpNeat.Core.EvaluationInfo">
            <summary>
            Encapsulates genome2 evaluation data; specifically whether the genome2 has been evaluated, the genome2's fitness,
            how many times the genome2 has been evaluated and if more than once then the mean fitness.
            
            Mean fitness is sometimes used when evaluations are non-determininstic (where each evaluation with the 
            same parameters results in a different fitness, usually following some distribution curve) or else 
            successive evaluations use different evaluation parameters and therefore result in different fitnesses. 
            This approach is sometimes used in order to evaluate against a very computationally expensive fitness
            scheme, or indeed a computationally intractable scheme - i.e. we only execute against some subset of the
            problem space for each genome2 evaluation, and thus we obtain a more representative value for a genome2's
            fitness by averaging over successive evaluations.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.EvaluationInfo.#ctor(System.Int32)">
            <summary>
            Construct and allocate the specified amount of memory for fitness history. Use
            zero if you don't require fitness history - but note that no arithmetic mean will be available.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.EvaluationInfo.SetFitness(System.Double)">
            <summary>
            Assign a fitness. If a fitness history buffer was created then the value will be
            enqueued in the buffer.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.EvaluationInfo.IncrEvaluationPassCount">
            <summary>
            Increments EvaluationPassCount.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.EvaluationInfo.Fitness">
            <summary>
            Gets the fitness value to be used by the evolution algorithm for selection of genomes
            (for reproduction) and species fitness sharing. If a fitness buffer is in use this will be the 
            average fitness for the last N fitness evaluations as held by the fitness history buffer,
            otherwise if no buffer is in use it is simply the fitness from the most recent evaluation.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.EvaluationInfo.MostRecentFitness">
            <summary>
            Gets the fitness from the most recent evaluation. This may be different to the Fitness property if a fitness
            history buffer is in use that averages out the reported fitness over a number of evaluations.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.EvaluationInfo.MeanFitness">
            <summary>
            Gets the arithmetic mean of the most recent fitnesses as stored in the fitness history buffer.
            Note that an exception will be thrown if the history buffer is not being used.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.EvaluationInfo.AlternativeFitness">
            <summary>
            Gets or sets an alternative fitness score. This value is provided to allow evaulators to report a number that is 
            more meaningful to humans, it is not used by the evolutionary algorithm in any way. The idea here is that fitness
            functions often apply complex traformations to one or more underlying fitness values to obtain a value with a number 
            of attributes that are desirable in fitenss functions (e.g. smooth fitness landscape). In applying those transformations
            the end fitness value can become hard to interpret directly, as such this value can be used to provide some meaningful
            underlying fitness value.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.EvaluationInfo.IsEvaluated">
            <summary>
            Gets a value indicating whether a genome2 has been evaluated at least once.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.EvaluationInfo.EvaluationCount">
            <summary>
            Gets the total number of times the genome2 has been evaluated. 
            </summary>
        </member>
        <member name="P:SharpNeat.Core.EvaluationInfo.EvaluationPassCount">
            <summary>
            Gets or sets the total number of times the genome2 has skipped evaluation.
            Some evaluation schemes re-evaluate genomes that persist between generations (e.g. elite genomes)
            at each generation, whereas other schemes may chose to not re-evaulate or only re-evaluate every Nth
            generation/attempt. This counter tracks how many times the genome2 has been skipped to support such schemes.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.EvaluationInfo.TotalEvaluationCount">
            <summary>
            Gets EvaluationCount + EvaluationPassCount.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.EvaluationInfo.FitnessHistoryLength">
            <summary>
            Gets the capacity of the fitness history buffer in use. Zero if no history buffer is being used.
            </summary>
        </member>
        <member name="T:SharpNeat.Core.CoordinateVector">
            <summary>
            General purpose representation of a point in a multidimensional space. A vector of coordinates, 
            each coordinate defining the position within a dimension/axis defined by an ID.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.CoordinateVector.#ctor(System.Collections.Generic.KeyValuePair{System.UInt64,System.Double}[])">
            <summary>
            Constructs a CoordinateVector using the provided array of ID/coordinate pairs.
            CoordinateVector elements must be sorted by ID.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.CoordinateVector.CoordArray">
            <summary>
            Gets an array containing the ID/coordinate pairs.
            CoordinateVector elements are sorted by ID
            </summary>
        </member>
        <member name="T:SharpNeat.Utility.FastRandom">
            <summary>
            A fast random number generator for .NET
            Colin Green, January 2005
            
            Key points:
             1) Based on a simple and fast xor-shift pseudo random number generator (RNG) specified in: 
             Marsaglia, George. (2003). Xorshift RNGs.
             http://www.jstatsoft.org/v08/i14/xorshift.pdf
             
             This particular implementation of xorshift has a period of 2^128-1. See the above paper to see
             how this can be easily extened if you need a longer period. At the time of writing I could find no 
             information on the period of System.Random for comparison.
            
             2) Faster than System.Random. Up to 8x faster, depending on which methods are called.
            
             3) Direct replacement for System.Random. This class implements all of the methods that System.Random 
             does plus some additional methods. The like named methods are functionally equivalent.
             
             4) Allows fast re-initialisation with a seed, unlike System.Random which accepts a seed at construction
             time which then executes a relatively expensive initialisation routine. This provides a vast speed improvement
             if you need to reset the pseudo-random number sequence many times, e.g. if you want to re-generate the same
             sequence of random numbers many times. An alternative might be to cache random numbers in an array, but that 
             approach is limited by memory capacity and the fact that you may also want a large number of different sequences 
             cached. Each sequence can be represented by a single seed value (int) when using FastRandom.
             
             Notes.
             A further performance improvement can be obtained by declaring local variables as static, thus avoiding 
             re-allocation of variables on each call. However care should be taken if multiple instances of
             FastRandom are in use or if being used in a multi-threaded environment.
            
            
            Colin Green, September 4th 2005
                Added NextBytesUnsafe() - commented out by default.
                Fixed bug in Reinitialise() - y,z and w variables were not being reset.
            
            
            Colin Green, December 2008. 
                Fix to Next() - Was previously able to return int.MaxValue, contrary to the method's contract and comments.
                Modified NextBool() to use _bitMask instead of a count of remaining bits. Also reset the bit buffer in Reinitialise().
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.FastRandom.#ctor">
            <summary>
            Initialises a new instance using time dependent seed.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.FastRandom.#ctor(System.Int32)">
            <summary>
            Initialises a new instance using an int value as seed.
            This constructor signature is provided to maintain compatibility with
            System.Random
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.FastRandom.Reinitialise(System.Int32)">
            <summary>
            Reinitialises using an int value as a seed.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.FastRandom.Next">
            <summary>
            Generates a random int over the range 0 to int.MaxValue-1.
            MaxValue is not generated in order to remain functionally equivalent to System.Random.Next().
            This does slightly eat into some of the performance gain over System.Random, but not much.
            For better performance see:
            
            Call NextInt() for an int over the range 0 to int.MaxValue.
            
            Call NextUInt() and cast the result to an int to generate an int over the full Int32 value range
            including negative values. 
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.FastRandom.Next(System.Int32)">
            <summary>
            Generates a random int over the range 0 to upperBound-1, and not including upperBound.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.FastRandom.Next(System.Int32,System.Int32)">
            <summary>
            Generates a random int over the range lowerBound to upperBound-1, and not including upperBound.
            upperBound must be >= lowerBound. lowerBound may be negative.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.FastRandom.NextDouble">
            <summary>
            Generates a random double. Values returned are from 0.0 up to but not including 1.0.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.FastRandom.NextBytes(System.Byte[])">
            <summary>
            Fills the provided byte array with random bytes.
            This method is functionally equivalent to System.Random.NextBytes(). 
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.FastRandom.NextUInt">
            <summary>
            Generates a uint. Values returned are over the full range of a uint, 
            uint.MinValue to uint.MaxValue, inclusive.
            
            This is the fastest method for generating a single random number because the underlying
            random number generator algorithm generates 32 random bits that can be cast directly to 
            a uint.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.FastRandom.NextInt">
            <summary>
            Generates a random int over the range 0 to int.MaxValue, inclusive. 
            This method differs from Next() only in that the range is 0 to int.MaxValue
            and not 0 to int.MaxValue-1.
            
            The slight difference in range means this method is slightly faster than Next()
            but is not functionally equivalent to System.Random.Next().
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.FastRandom.NextBool">
            <summary>
            Generates a single random bit.
            This method's performance is improved by generating 32 bits in one operation and storing them
            ready for future calls.
            </summary>
        </member>
        <member name="T:SharpNeat.SpeciationStrategies.RandomClusteringStrategy`1">
            <summary>
            A speciation strategy that allocates genomes to species randomly.
            Although allocation is random the strategy does maintain evenly sized species.
            Primarily used for testing/debugging and demonstrating comparative effectiveness of random
            allocation compared to other strategies.
            </summary>
            <typeparam name="TGenome">The genome2 type to apply clustering to.</typeparam>
        </member>
        <member name="M:SharpNeat.SpeciationStrategies.RandomClusteringStrategy`1.InitializeSpeciation(System.Collections.Generic.IList{`0},System.Int32)">
            <summary>
            Speciates the genomes in genomeList into the number of species specified by specieCount
            and returns a newly constructed list of Specie objects containing the speciated genomes.
            </summary>
        </member>
        <member name="M:SharpNeat.SpeciationStrategies.RandomClusteringStrategy`1.SpeciateGenomes(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{SharpNeat.Core.Specie{`0}})">
            <summary>
            Speciates the genomes in genomeList into the provided species. It is assumed that
            the genomeList represents all of the required genomes and that the species are currently empty.
            
            This method can be used for initialization or completely respeciating an existing genome2 population.
            </summary>
        </member>
        <member name="M:SharpNeat.SpeciationStrategies.RandomClusteringStrategy`1.SpeciateOffspring(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{SharpNeat.Core.Specie{`0}})">
            <summary>
            Speciates the offspring genomes in genomeList into the provided species. In contrast to
            SpeciateGenomes() genomeList is taken to be a list of new genomes (e.g. offspring) that should be 
            added to existing species. That is, the species contain genomes that are not in genomeList
            that we wish to keep; typically these would be elite genomes that are the parents of the
            offspring.
            </summary>
        </member>
        <member name="T:SharpNeat.Core.UpdateScheme">
            <summary>
            Represents an update scheme for an IEvolutionAlgorithm. e.g. update per some time duration or 
            some number of generations.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.UpdateScheme.#ctor(System.UInt32)">
            <summary>
            Constructs a 'per generations' update scheme.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.UpdateScheme.#ctor(System.TimeSpan)">
            <summary>
            Constructs a 'per timespan' update scheme.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.UpdateScheme.UpdateMode">
            <summary>
            Gets the update scheme's mode.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.UpdateScheme.Generations">
            <summary>
            Gets the number of generations between updates; Applies only to the generational update scheme.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.UpdateScheme.TimeSpan">
            <summary>
            Gets the number timespan between updates; Applies only to the timespan update scheme.
            </summary>
        </member>
        <member name="T:SharpNeat.Core.SerialGenomeListEvaluator`2">
            <summary>
            A concrete implementation of IGenomeListEvaluator that evaulates genomes independently of each other
            and in series on a single thread. 
            
            Genome decoding is performed by a provided IGenomeDecoder.
            Phenome evaluation is performed by a provided IPhenomeEvaluator.
            
            This class evaluates on a single thread only, and therefore is a good choice when debugging code.
            </summary>
            <typeparam name="TGenome">The genome2 type that is decoded.</typeparam>
            <typeparam name="TPhenome">The phenome type that is decoded to and then evaluated.</typeparam>
        </member>
        <member name="M:SharpNeat.Core.SerialGenomeListEvaluator`2.#ctor(SharpNeat.Core.IGenomeDecoder{`0,`1},SharpNeat.Core.IPhenomeEvaluator{`1})">
            <summary>
            Construct with the provided IGenomeDecoder and IPhenomeEvaluator.
            Phenome caching is enabled by default.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.SerialGenomeListEvaluator`2.#ctor(SharpNeat.Core.IGenomeDecoder{`0,`1},SharpNeat.Core.IPhenomeEvaluator{`1},System.Boolean)">
            <summary>
            Construct with the provided IGenomeDecoder, IPhenomeEvaluator and enablePhenomeCaching flag.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.SerialGenomeListEvaluator`2.Evaluate(System.Collections.Generic.IList{`0})">
            <summary>
            Evaluates a list of genomes. Here we decode each genome2 in series using the contained
            IGenomeDecoder and evaluate the resulting TPhenome using the contained IPhenomeEvaluator.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.SerialGenomeListEvaluator`2.Reset">
            <summary>
            Reset the internal state of the evaluation scheme if any exists.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.SerialGenomeListEvaluator`2.EvaluationCount">
            <summary>
            Gets the total number of individual genome2 evaluations that have been performed by this evaluator.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.SerialGenomeListEvaluator`2.StopConditionSatisfied">
            <summary>
            Gets a value indicating whether some goal fitness has been achieved and that
            the the evolutionary algorithm/search should stop. This property's value can remain false
            to allow the algorithm to run indefinitely.
            </summary>
        </member>
        <member name="T:SharpNeat.Core.IGenomeFactory`1">
            <summary>
            Generic interface genome2 factory classes. Genome factories are intended to be used for creating initial
            populations, either random populations or from one or more seed genomes. However, genome2 reproduction
            is performed via the overloaded IGenome.CreateOffspring() methods, placing these methods on
            IGenome gives reproduction methods direct and convenient access to internal genome2 data.
            
            Concrete IGenomeFactory classes are expected to contain all parameters used for creating and breeding
            genomes such as (in NEAT) the number of input/output neurons, connection weight range and mutation 
            rate. Concrete IGenomes are therefore expected to be given a reference to their concrete factory class
            upon construction, this gives them access to parameters for use in IGenome.CreateOffspring() - which may 
            change during evolution, e.g. in the case of phased searching in NEAT.
            </summary>
            <typeparam name="TGenome">The genome2 type to act as a factory for.</typeparam>
        </member>
        <member name="M:SharpNeat.Core.IGenomeFactory`1.CreateGenomeList(System.Int32,System.UInt32)">
            <summary>
            Creates a list of randomly initialised genomes.
            </summary>
            <param name="length">The number of genomes to create.</param>
            <param name="birthGeneration">The current evolution algorithm generation. 
            Assigned to the new genomes as their birth generation.</param>
        </member>
        <member name="M:SharpNeat.Core.IGenomeFactory`1.CreateGenomeList(System.Int32,System.UInt32,`0)">
            <summary>
            Creates a list of genomes spawned from a seed genome2. Spawning uses asexual reproduction.
            </summary>
            <param name="length">The number of genomes to create.</param>
            <param name="birthGeneration">The current evolution algorithm generation.
            Assigned to the new genomes as their birth generation.</param>
            <param name="seedGenome">The seed genome2.</param>
        </member>
        <member name="M:SharpNeat.Core.IGenomeFactory`1.CreateGenomeList(System.Int32,System.UInt32,System.Collections.Generic.List{`0})">
            <summary>
            Creates a list of genomes spawned from a list of seed genomes. Spawning uses asexual reproduction and
            typically we repeatedly loop over (and spawn from) the seed genomes until we have the required number
            of spawned genomes.
            </summary>
            <param name="length">The number of genomes to create.</param>
            <param name="birthGeneration">The current evolution algorithm generation. 
            Assigned to the new genomes as their birth generation.</param>
            <param name="seedGenomeList">A list of seed genomes.</param>
        </member>
        <member name="M:SharpNeat.Core.IGenomeFactory`1.CreateGenome(System.UInt32)">
            <summary>
            Creates a single randomly initialised genome2.
            </summary>
            <param name="birthGeneration">The current evolution algorithm generation. 
            Assigned to the new genome2 as its birth generation.</param>
        </member>
        <member name="P:SharpNeat.Core.IGenomeFactory`1.GenomeIdGenerator">
            <summary>
            Gets the genome2 ID generator for the factory. This is used internally when creating new
            genomes and is exposed as a public property so that genomes that are spawning offspring can 
            generate IDs in the same ID space.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.IGenomeFactory`1.SearchMode">
            <summary>
            Gets or sets a mode value. This is intended as a means for an evolution algorithm to convey changes
            in search mode to genomes, and because the set of modes is specific to each concrete implementation
            of an IEvolutionAlgorithm the mode is defined as an integer (rather than an enum[eration]).
            E.g. SharpNEAT's implementation of NEAT uses an evolutionary algorithm that alternates between
            a complexifying and simplifying mode, in order to do this the algorithm class needs to notify the genomes
            of the current mode so that the CreateOffspring() methods are able to generate offspring appropriately - 
            e.g. we avoid adding new nodes and connections and increase the rate of deletion mutations when in
            simplifying mode.
            </summary>
        </member>
        <member name="T:SharpNeat.Phenomes.NeuralNets.RelaxingRecurrentNetwork">
             <summary>
             A version of RecurrentNetwork that activates a network until it becomes 'relaxed' rather than for some
             fixed number of iterations. This class is exactly the same as RecurrentNetwork in all other respects;
             See that class for more detailed info.
            
             A network is defined as being relaxed when the change in output signal value between two successive
             update iterations is less than some threshold value (defined by maxAllowedSignalDelta on the constructor)
             for all hidden and output neurons (inpus and bias neurons have a fixed output value).
             </summary>
        </member>
        <member name="M:SharpNeat.Phenomes.NeuralNets.RelaxingRecurrentNetwork.#ctor(System.Collections.Generic.List{SharpNeat.Phenomes.NeuralNets.Neuron},System.Collections.Generic.List{SharpNeat.Phenomes.NeuralNets.Connection},System.Int32,System.Int32,System.Int32,System.Double)">
            <summary>
            Constructs a RecurrentNetwork with the provided pre-built neurons and connections.
            </summary>
        </member>
        <member name="M:SharpNeat.Phenomes.NeuralNets.RelaxingRecurrentNetwork.Activate">
            <summary>
            Activate the network until it becomes 'relaxed' or until maxTimesteps is reached. If maxIterations 
            is reached without the network relaxing then the IsValidState property will return false, although 
            the network outputs are still provided and can be read as normal.
            </summary>
        </member>
        <member name="M:SharpNeat.Phenomes.NeuralNets.RelaxingRecurrentNetwork.ResetState">
            <summary>
            Reset the network's internal state and isValidState flag.
            </summary>
        </member>
        <member name="P:SharpNeat.Phenomes.NeuralNets.RelaxingRecurrentNetwork.IsStateValid">
            <summary>
            Indicates if the internal state is valid. Returns false if the network did not relax within the
            maximum number of timesteps.
            </summary>
        </member>
        <member name="T:SharpNeat.Genomes.HyperNeat.CppnGenomeFactory">
            <summary>
            A sub-class of NeatGenomeFactory for creating CPPN genomes.
            </summary>
        </member>
        <member name="T:SharpNeat.Genomes.Neat.NeatGenomeFactory">
            <summary>
            An IGenomeFactory for NeatGenomes. We use the factory as a means of generating an initial population either
            randomly or using a seed genome2 or genomes.
            Subsequently all NeatGenome objects keep a reference to this factory object for convenient access to
            NeatGenome parameters and ID generator objects.
            </summary>
        </member>
        <member name="F:SharpNeat.Genomes.Neat.NeatGenomeFactory._rng">
            <summary>Random number generator associated with this factory.</summary>
        </member>
        <member name="F:SharpNeat.Genomes.Neat.NeatGenomeFactory._activationFnLibrary">
            <summary>Activation function library associated with this factory.</summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenomeFactory.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs with default NeatGenomeParameters and ID generators initialized to zero.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenomeFactory.#ctor(System.Int32,System.Int32,SharpNeat.Genomes.Neat.NeatGenomeParameters)">
            <summary>
            Constructs a NeatGenomeFactory with the provided NeatGenomeParameters and ID generators initialized to zero.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenomeFactory.#ctor(System.Int32,System.Int32,SharpNeat.Genomes.Neat.NeatGenomeParameters,SharpNeat.Utility.UInt32IdGenerator,SharpNeat.Utility.UInt32IdGenerator)">
            <summary>
            Constructs a NeatGenomeFactory with the provided NeatGenomeParameters and ID generators.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenomeFactory.#ctor(System.Int32,System.Int32,SharpNeat.Network.IActivationFunctionLibrary)">
            <summary>
            Constructs with default NeatGenomeParameters, ID generators initialized to zero and the provided
            IActivationFunctionLibrary.
            This overload required for CPPN support.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenomeFactory.#ctor(System.Int32,System.Int32,SharpNeat.Network.IActivationFunctionLibrary,SharpNeat.Genomes.Neat.NeatGenomeParameters)">
            <summary>
            Constructs with ID generators initialized to zero and the provided
            IActivationFunctionLibrary and NeatGenomeParameters.
            This overload required for CPPN support.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenomeFactory.#ctor(System.Int32,System.Int32,SharpNeat.Network.IActivationFunctionLibrary,SharpNeat.Genomes.Neat.NeatGenomeParameters,SharpNeat.Utility.UInt32IdGenerator,SharpNeat.Utility.UInt32IdGenerator)">
            <summary>
            Constructs with the provided IActivationFunctionLibrary, NeatGenomeParameters and
            ID Generators.
            This overload required for CPPN support.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenomeFactory.CreateGenomeList(System.Int32,System.UInt32)">
            <summary>
            Creates a list of randomly initialised genomes.
            </summary>
            <param name="length">The number of genomes to create.</param>
            <param name="birthGeneration">The current evolution algorithm generation. 
            Assigned to the new genomes as their birth generation.</param>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenomeFactory.CreateGenomeList(System.Int32,System.UInt32,SharpNeat.Genomes.Neat.NeatGenome)">
            <summary>
            Creates a list of genomes spawned from a seed genome2. Spawning uses asexual reproduction.
            </summary>
            <param name="length">The number of genomes to create.</param>
            <param name="birthGeneration">The current evolution algorithm generation. 
            Assigned to the new genomes as their birth generation.</param>
            <param name="seedGenome">The seed genome2 to spawn new genomes from.</param>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenomeFactory.CreateGenomeList(System.Int32,System.UInt32,System.Collections.Generic.List{SharpNeat.Genomes.Neat.NeatGenome})">
            <summary>
            Creates a list of genomes spawned from a list of seed genomes. Spawning uses asexual reproduction and
            typically we would simply repeatedly loop over (and spawn from) the seed genomes until we have the 
            required number of spawned genomes.
            </summary>
            <param name="length">The number of genomes to create.</param>
            <param name="birthGeneration">The current evolution algorithm generation. 
            Assigned to the new genomes as their birth generation.</param>
            <param name="seedGenomeList">A list of seed genomes from which to spawn new genomes from.</param>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenomeFactory.CreateGenome(System.UInt32)">
            <summary>
            Creates a single randomly initialised genome2. 
            A random set of connections are made form the input to the output neurons, the number of 
            connections made is based on the NeatGenomeParameters.InitialInterconnectionsProportion
            which specifies the proportion of all posssible input-output connections to be made in
            initial genomes.
            
            The connections that are made are allocated innovation IDs in a consistent manner across
            the initial population of genomes. To do this we allocate IDs sequentially to all possible 
            interconnections and then randomly select some proportion of connections for inclusion in the
            genome2. In addition, for this scheme to work the innovation ID generator must be reset to zero
            prior to each call to CreateGenome(), and a test is made to ensure this is the case.
            
            The consistent allocation of innovation IDs ensure that equivalent connections in different 
            genomes have the same innovation ID, and although this isn't strictly necessary it is 
            required for sexual reproduction to work effectively - like structures are detected by comparing
            innovation IDs only.
            </summary>
            <param name="birthGeneration">The current evolution algorithm generation. 
            Assigned to the new genome2 as its birth generation.</param>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenomeFactory.NextGenomeId">
            <summary>
            Convenient method for obtaining the next genome2 ID.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenomeFactory.NextInnovationId">
            <summary>
            Convenient method for obtaining the next innovation ID.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenomeFactory.GenerateRandomConnectionWeight">
            <summary>
            Convenient method for generating a new random connection weight that conforms to the connection
            weight range defined by the NeatGenomeParameters.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenomeFactory.SampleGaussianDistribution(System.Double,System.Double)">
            <summary>
            Gets a variable from the Gaussian distribution with the provided mean and standard deviation.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenomeFactory.CreateGenome(System.UInt32,System.UInt32,SharpNeat.Genomes.Neat.NeuronGeneList,SharpNeat.Genomes.Neat.ConnectionGeneList,System.Int32,System.Int32)">
            <summary>
            Overridable method to allow alternative NeatGenome classes to be used.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenomeFactory.CreateGenomeCopy(SharpNeat.Genomes.Neat.NeatGenome,System.UInt32,System.UInt32)">
            <summary>
            Overridable method to allow alternative NeatGenome classes to be used.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenomeFactory.CreateNeuronGene(System.UInt32,SharpNeat.Network.NodeType)">
            <summary>
            Overridable method to allow alternative NeuronGene classes to be used.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenomeFactory.GenomeIdGenerator">
            <summary>
            Gets the factory's genome2 ID generator.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenomeFactory.SearchMode">
            <summary>
            Gets or sets a mode value. This is intended as a means for an evolution algorithm to convey changes
            in search mode to genomes, and because the set of modes is specific to each concrete implementation
            of an IEvolutionAlgorithm the mode is defined as an integer (rather than an enum[eration]).
            E.g. SharpNEAT's implementation of NEAT uses an evolutionary algorithm that alternates between
            a complexifying and simplifying mode, in order to do this the algorithm class needs to notify the genomes
            of the current mode so that the CreateOffspring() methods are able to generate offspring appropriately - 
            e.g. we avoid adding new nodes and connections and increase the rate of deletion mutations when in
            simplifying mode.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenomeFactory.NeatGenomeParameters">
            <summary>
            Gets the factory's NeatGenomeParameters currently in effect.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenomeFactory.ActivationFnLibrary">
            <summary>
            Gets the factory's activation function library.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenomeFactory.InnovationIdGenerator">
            <summary>
            Gets the factory's innovation ID generator.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenomeFactory.AddedConnectionBuffer">
            <summary>
            Gets the history buffer of added connections. Used when adding new connections to check if an
            identical connection has been added to a genome2 elsewhere in the population. This allows re-use
            of the same innovation ID for like connections.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenomeFactory.AddedNeuronBuffer">
            <summary>
            Gets the history buffer of added neurons. Used when adding new neurons to check if an
            identical neuron has been added to a genome2 elsewhere in the population. This allows re-use
            of the same innovation ID for like neurons.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenomeFactory.Rng">
            <summary>
            Gets a random number generator associated with the factory. 
            Note. The provided RNG is not thread safe, if concurrent use is required then sync locks
            are necessary or some other RNG mechanism.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenomeFactory.Stats">
            <summary>
            Gets some statistics assocated with the factory and NEAT genomes that it has spawned.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.HyperNeat.CppnGenomeFactory.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs with default NeatGenomeParameters, ID generators initialized to zero and a
            default IActivationFunctionLibrary.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.HyperNeat.CppnGenomeFactory.#ctor(System.Int32,System.Int32,SharpNeat.Network.IActivationFunctionLibrary)">
            <summary>
            Constructs with default NeatGenomeParameters, ID generators initialized to zero and the
            provided IActivationFunctionLibrary.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.HyperNeat.CppnGenomeFactory.#ctor(System.Int32,System.Int32,SharpNeat.Network.IActivationFunctionLibrary,SharpNeat.Genomes.Neat.NeatGenomeParameters)">
            <summary>
            Constructs with the provided IActivationFunctionLibrary and NeatGenomeParameters.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.HyperNeat.CppnGenomeFactory.#ctor(System.Int32,System.Int32,SharpNeat.Network.IActivationFunctionLibrary,SharpNeat.Genomes.Neat.NeatGenomeParameters,SharpNeat.Utility.UInt32IdGenerator,SharpNeat.Utility.UInt32IdGenerator)">
            <summary>
            Constructs with the provided IActivationFunctionLibrary, NeatGenomeParameters and ID generators.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.HyperNeat.CppnGenomeFactory.CreateNeuronGene(System.UInt32,SharpNeat.Network.NodeType)">
            <summary>
            Override that randomly assigns activation functions to neuron's from an activation function library
            based on each library item's selection probability.
            </summary>
        </member>
        <member name="T:SharpNeat.DistanceMetrics.EuclideanDistanceMetric">
            <summary>
            Euclidean distance metric.
            
            The Euclidean distance is given by sqrt(sum(delta^2))
            Where [delta] is the absolute position difference in a given dimension (on a given axis).
            </summary>
        </member>
        <member name="M:SharpNeat.DistanceMetrics.EuclideanDistanceMetric.MeasureDistance(SharpNeat.Core.CoordinateVector,SharpNeat.Core.CoordinateVector,System.Double)">
            <summary>
            Tests if the distance between two positions is less than some threshold.
            
            A simple way of implementing this method would be to calculate the distance between the
            two coordinates and test if it is less than the threshold. However, that approach requires that all of the
            elements in both CoordinateVectors be fully compared. We can improve performance in the general case
            by testing if the threshold has been passed after each vector element comparison thus allowing an early exit
            from the method for many calls. Further to this, we can begin comparing from the ends of the vectors where 
            differences are most likely to occur.
            </summary>
        </member>
        <member name="M:SharpNeat.DistanceMetrics.EuclideanDistanceMetric.MeasureDistance(SharpNeat.Core.CoordinateVector,SharpNeat.Core.CoordinateVector)">
            <summary>
            Measures the distance between two positions.
            </summary>
        </member>
        <member name="M:SharpNeat.DistanceMetrics.EuclideanDistanceMetric.CalculateCentroid(System.Collections.Generic.IList{SharpNeat.Core.CoordinateVector})">
            <summary>
            Calculates the centroid for the given set of points.
            For the Euclidean distance metric the centroid is given by calculating the componentwise mean over the
            set of points.
            </summary>
        </member>
        <member name="M:SharpNeat.DistanceMetrics.EuclideanDistanceMetric.CalculateCentroidParallel(System.Collections.Generic.IList{SharpNeat.Core.CoordinateVector})">
            <summary>
            Parallelized version of CalculateCentroid().
            </summary>
        </member>
        <member name="T:SharpNeat.Decoders.HyperNeat.SubstrateNodeSet">
            <summary>
            Represenst a set of nodes on a substrate. Nodesets are used to represent sets such as the input and output nodes.
            Hidden nodes can be represented as layers with each layer being represented by a set. This allows connection mapping
            to be defined between between sets.
            </summary>
        </member>
        <member name="M:SharpNeat.Decoders.HyperNeat.SubstrateNodeSet.#ctor">
            <summary>
            Construct an empty nodeset. Node can be added after construction.
            </summary>
        </member>
        <member name="M:SharpNeat.Decoders.HyperNeat.SubstrateNodeSet.#ctor(System.Int32)">
            <summary>
            Construct an empty nodeset with an initial capacity. Node can be added after construction.
            </summary>
        </member>
        <member name="M:SharpNeat.Decoders.HyperNeat.SubstrateNodeSet.#ctor(System.Collections.Generic.List{SharpNeat.Decoders.HyperNeat.SubstrateNode})">
            <summary>
            Construct a nodeset with the provided list of nodes.
            </summary>
        </member>
        <member name="P:SharpNeat.Decoders.HyperNeat.SubstrateNodeSet.NodeList">
            <summary>
            Get the nodes in the nodeset.
            </summary>
        </member>
        <member name="T:SharpNeat.Utility.KeyedCircularBuffer`2">
            <summary>
            A generic circular buffer of KeyValuePairs. The values are retrievable by their
            key. Old key-value pairs are overwritten when the circular buffer runs out of
            empty elements to place items into, as this happens the internal dictionary that 
            maintains the lookup ability is also updated to reflect only the items in the 
            circular buffer.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.KeyedCircularBuffer`2.#ctor(System.Int32)">
            <summary>
            Constructs a circular buffer with the specified capacity.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.KeyedCircularBuffer`2.Clear">
            <summary>
            Clear the buffer.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.KeyedCircularBuffer`2.Enqueue(`0,`1)">
            <summary>
            Enqueue a new item. This overwrites the oldest item in the buffer if the buffer
            has reached capacity.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.KeyedCircularBuffer`2.Enqueue(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Enqueue a new item. This overwrites the oldest item in the buffer if the buffer
            has reached capacity.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.KeyedCircularBuffer`2.Dequeue">
            <summary>
            Remove the oldest item from the back end of the buffer and return it.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.KeyedCircularBuffer`2.Pop">
            <summary>
            Pop the most recently added item from the front end of the buffer and return it.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.KeyedCircularBuffer`2.ContainsKey(`0)">
            <summary>
            Determines whether the KeyedCircularBuffer contains the specified key.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.KeyedCircularBuffer`2.TryGetValue(`0,`1@)">
            <summary>
            Gets the value associated with the specified key. 
            </summary>
        </member>
        <member name="P:SharpNeat.Utility.KeyedCircularBuffer`2.Item(`0)">
            <summary>
            Gets the value associated with the specified key. If the specified key is not found,
            a get operation throws a KeyNotFoundException.
            </summary>
        </member>
        <member name="T:SharpNeat.Network.BipolarGaussian">
            <summary>
            Bipolar gaussian activation function. Output range is -1 to 1, that is, the tails of the gaussian
            distribution curve tend towards -1 as abs(x) -> Infinity and the gaussian's peak is at y = 1.
            </summary>
        </member>
        <member name="F:SharpNeat.Network.BipolarGaussian.__DefaultInstance">
            <summary>
            Default instance provided as a public static field.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.BipolarGaussian.Calculate(System.Double)">
            <summary>
            Calculates the output value for the specified input value.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.BipolarGaussian.Calculate(System.Single)">
            <summary>
            Calculates the output value for the specified input value with float/single precision.
            This single precision overload of Calculate() will be used in neural network code 
            that has been specifically written to use floats instead of doubles.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.BipolarGaussian.FunctionId">
            <summary>
            Gets the unique ID of the function. Stored in network XML to identify which function a network or neuron 
            is using.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.BipolarGaussian.FunctionString">
            <summary>
            Gets a human readable string representation of the function. E.g 'y=1/x'.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.BipolarGaussian.FunctionDescription">
            <summary>
            Gets a human readable verbose description of the activation function.
            </summary>
        </member>
        <member name="T:SharpNeat.Network.ConnectionEndpointsStruct">
            <summary>
            Represents a connection between two nodes. Used primarily as a key into a
            Dictionary that uniquely identifies connections by their end points.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.ConnectionEndpointsStruct.#ctor(System.UInt32,System.UInt32)">
            <summary>
            Construct with the provided source and target node IDs.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.ConnectionEndpointsStruct.Equals(SharpNeat.Network.ConnectionEndpointsStruct,SharpNeat.Network.ConnectionEndpointsStruct)">
            <summary>
            Implementation for IEqualityComparer.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.ConnectionEndpointsStruct.GetHashCode(SharpNeat.Network.ConnectionEndpointsStruct)">
            <summary>
            Implementation for IEqualityComparer.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.ConnectionEndpointsStruct.SourceNodeId">
            <summary>
            Gets the source node ID.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.ConnectionEndpointsStruct.TargetNodeId">
            <summary>
            Gets the target node ID.
            </summary>
        </member>
        <member name="T:SharpNeat.Network.DefaultActivationFunctionLibrary">
            <summary>
            Default implementation of an IActivationFunctionLibrary. 
            Also provides static factory methods to create libraries with commonly used activation functions.
            </summary>
        </member>
        <member name="T:SharpNeat.Network.IActivationFunctionLibrary">
            <summary>
            Represents a library of activation functions. Primarily for use in HyperNEAT.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.IActivationFunctionLibrary.GetFunction(System.Int32)">
            <summary>
            Gets the function with the specified integer ID.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.IActivationFunctionLibrary.GetRandomFunction(SharpNeat.Utility.FastRandom)">
            <summary>
            Randomly select a function based on each function's selection probability.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.IActivationFunctionLibrary.GetFunctionList">
            <summary>
            Gets a list of all functions in the library.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.DefaultActivationFunctionLibrary.#ctor(System.Collections.Generic.IList{SharpNeat.Network.ActivationFunctionInfo})">
            <summary>
            Constructs an activation function library with the provided list of activation functions.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.DefaultActivationFunctionLibrary.GetFunction(System.Int32)">
            <summary>
            Gets the function with the specified integer ID.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.DefaultActivationFunctionLibrary.GetRandomFunction(SharpNeat.Utility.FastRandom)">
            <summary>
            Randomly select a function based on each function's selection probability.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.DefaultActivationFunctionLibrary.GetFunctionList">
            <summary>
            Gets a list of all functions in the library.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.DefaultActivationFunctionLibrary.CreateLibraryNeat(SharpNeat.Network.IActivationFunction)">
            <summary>
            Create an IActivationFunctionLibrary for use with NEAT.
            NEAT uses the same activation function for all neurons/nodes therefore this factory method
            creates an IActivationFunction containing only the single provided IActivationFunction.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.DefaultActivationFunctionLibrary.CreateLibraryCppn">
            <summary>
            Create an IActivationFunctionLibrary for use with CPPNs.
            </summary>
        </member>
        <member name="T:SharpNeat.Core.RunState">
            <summary>
            An enumeration of possible execution states for an IEvolutionAlgorithm.
            </summary>
        </member>
        <member name="F:SharpNeat.Core.RunState.NotReady">
            <summary>
            Not yet initialized.
            </summary>
        </member>
        <member name="F:SharpNeat.Core.RunState.Ready">
            <summary>
            Initialized and ready to start.
            </summary>
        </member>
        <member name="F:SharpNeat.Core.RunState.Running">
            <summary>
            The algorithm is running.
            </summary>
        </member>
        <member name="F:SharpNeat.Core.RunState.Paused">
            <summary>
            The algorithm has been paused, either due to a user request or because a stop condition
            has been met. The algorithm can be restarted if the stop condition is no longer true.
            </summary>
        </member>
        <member name="F:SharpNeat.Core.RunState.Terminated">
            <summary>
            The algorithm thread has terminated. The algorithm cannot be restarted from this state, a new
            algorithm object must be created and started afresh.
            </summary>
        </member>
        <member name="T:SharpNeat.Utility.RouletteWheelLayout">
            <summary>
            Represents the layout of a roulette wheel where each sector has different degrees of arc and thus
            probability of being selected.
            For use by the RouletteWheel class.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.RouletteWheelLayout.#ctor(System.Double[])">
            <summary>
            Construct the layout with provided probabilities. The provided probabilites do not have to add 
            up to 1.0 as we normalise them so that their total equals 1.0. In that sense they are not true
            probabilities until they have been normalised.
            </summary>
        </member>
        <member name="M:SharpNeat.Utility.RouletteWheelLayout.#ctor(SharpNeat.Utility.RouletteWheelLayout)">
            <summary>
            Copy constructor. Avoids normalisation of probabilities as this has already been done.
            </summary>
        </member>
        <member name="P:SharpNeat.Utility.RouletteWheelLayout.Probabilities">
            <summary>
            Gets the array of probabilities.
            </summary>
        </member>
        <member name="T:SharpNeat.Network.StepFunction">
            <summary>
            Step activation function.
            </summary>
        </member>
        <member name="F:SharpNeat.Network.StepFunction.__DefaultInstance">
            <summary>
            Default instance provided as a public static field.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.StepFunction.Calculate(System.Double)">
            <summary>
            Calculates the output value for the specified input value.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.StepFunction.Calculate(System.Single)">
            <summary>
            Calculates the output value for the specified input value with float/single precision.
            This single precision overload of Calculate() will be used in neural network code 
            that has been specifically written to use floats instead of doubles.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.StepFunction.FunctionId">
            <summary>
            Gets the unique ID of the function. Stored in network XML to identify which function a network or neuron 
            is using.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.StepFunction.FunctionString">
            <summary>
            Gets a human readable string representation of the function. E.g 'y=1/x'.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.StepFunction.FunctionDescription">
            <summary>
            Gets a human readable verbose description of the activation function.
            </summary>
        </member>
        <member name="T:SharpNeat.Network.SteepenedSigmoid">
            <summary>
            Sigmoid activation function with a steeper curve than the PlainSimple function.
            </summary>
        </member>
        <member name="F:SharpNeat.Network.SteepenedSigmoid.__DefaultInstance">
            <summary>
            Default instance provided as a public static field.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.SteepenedSigmoid.Calculate(System.Double)">
            <summary>
            Calculates the output value for the specified input value.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.SteepenedSigmoid.Calculate(System.Single)">
            <summary>
            Calculates the output value for the specified input value with float/single precision.
            This single precision overload of Calculate() will be used in neural network code 
            that has been specifically written to use floats instead of doubles.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.SteepenedSigmoid.FunctionId">
            <summary>
            Gets the unique ID of the function. Stored in network XML to identify which function a network or neuron 
            is using.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.SteepenedSigmoid.FunctionString">
            <summary>
            Gets a human readable string representation of the function. E.g 'y=1/x'.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.SteepenedSigmoid.FunctionDescription">
            <summary>
            Gets a human readable verbose description of the activation function.
            </summary>
        </member>
        <member name="T:SharpNeat.Network.Linear">
            <summary>
            Linear activation function with clipping. By 'clipping' we mean the output value is linear between
            x = -1 and x = 1. Below -1 and above +1 the output is clipped at -1 and +1 respectively.
            </summary>
        </member>
        <member name="F:SharpNeat.Network.Linear.__DefaultInstance">
            <summary>
            Default instance provided as a public static field.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.Linear.Calculate(System.Double)">
            <summary>
            Calculates the output value for the specified input value.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.Linear.Calculate(System.Single)">
            <summary>
            Calculates the output value for the specified input value with float/single precision.
            This single precision overload of Calculate() will be used in neural network code 
            that has been specifically written to use floats instead of doubles.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.Linear.FunctionId">
            <summary>
            Gets the unique ID of the function. Stored in network XML to identify which function a network or neuron 
            is using.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.Linear.FunctionString">
            <summary>
            Gets a human readable string representation of the function. E.g 'y=1/x'.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.Linear.FunctionDescription">
            <summary>
            Gets a human readable verbose description of the activation function.
            </summary>
        </member>
        <member name="T:SharpNeat.Network.BipolarSigmoid">
            <summary>
            Bipolar sigmoid activation function. Output range is -1 to 1 instead of the more normal 0 to 1.
            </summary>
        </member>
        <member name="F:SharpNeat.Network.BipolarSigmoid.__DefaultInstance">
            <summary>
            Default instance provided as a public static field.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.BipolarSigmoid.Calculate(System.Double)">
            <summary>
            Calculates the output value for the specified input value.
            </summary>
        </member>
        <member name="M:SharpNeat.Network.BipolarSigmoid.Calculate(System.Single)">
            <summary>
            Calculates the output value for the specified input value with float/single precision.
            This single precision overload of Calculate() will be used in neural network code 
            that has been specifically written to use floats instead of doubles.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.BipolarSigmoid.FunctionId">
            <summary>
            Gets the Gets the unique ID of the function. Stored in network XML to identify which function a network or neuron 
            is using.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.BipolarSigmoid.FunctionString">
            <summary>
            Gets a human readable string representation of the function. E.g 'y=1/x'.
            </summary>
        </member>
        <member name="P:SharpNeat.Network.BipolarSigmoid.FunctionDescription">
            <summary>
            Gets a human readable verbose description of the activation function.
            </summary>
        </member>
        <member name="T:SharpNeat.Genomes.Neat.AddedNeuronGeneStruct">
            <summary>
            Represents an added neuron. When a neuron is added to a neural network in NEAT an existing
            connection between two neurons is discarded and replaced with the new neuron and two new connections,
            one connection between the source neuron and the new neuron and another from the new neuron to the target neuron.
            This struct represents those three IDs.
            
            This struct exists to represent newly added structure in a history buffer of added structures. This allows us to 
            re-use IDs where a mutation recreates a structure that has previously occured through previous mutations on other 
            genomes.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.AddedNeuronGeneStruct.#ctor(SharpNeat.Utility.UInt32IdGenerator)">
            <summary>
            Construct by assigning new IDs gemnerated by the provided UInt32IdGenerator.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.AddedNeuronGeneStruct.AddedNeuronId">
            <summary>
            Gets the added neuron's ID.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.AddedNeuronGeneStruct.AddedInputConnectionId">
            <summary>
            Gets the added input connection's ID.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.AddedNeuronGeneStruct.AddedOutputConnectionId">
            <summary>
            Gets the added output connection's ID.
            </summary>
        </member>
        <member name="T:SharpNeat.Genomes.Neat.NeuronGeneList">
            <summary>
            Represents a sorted list of NeuronGene objects. The sorting of the items is done on request
            rather than being strictly enforced at all times (e.g. as part of adding and removing items). This
            approach is currently more convenient for use in some of the routines that work with NEAT genomes.
            
            Because we are not using a strictly sorted list such as the generic class SortedList[K,V] a customised 
            BinarySearch() method is provided for fast lookup of items if the list is known to be sorted. If the list is
            not sorted then the BinarySearch method's behaviour is undefined. This is potentially a source of bugs 
            and thus this class should probably migrate to SortedList[K,V] or be modified to ensure items are sorted 
            prior to a binary search.
            
            Sort order is with respect to connection gene innovation ID.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeuronGeneList.#ctor">
            <summary>
            Construct an empty list.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeuronGeneList.#ctor(System.Int32)">
            <summary>
            Construct an empty list with the specified capacity.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeuronGeneList.#ctor(System.Collections.Generic.ICollection{SharpNeat.Genomes.Neat.NeuronGene})">
            <summary>
            Copy constructor. The newly allocated list has a capacity 1 larger than copyFrom
            allowing for a single add node mutation to occur without reallocation of memory.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeuronGeneList.InsertIntoPosition(SharpNeat.Genomes.Neat.NeuronGene)">
            <summary>
            Inserts a NeuronGene into its correct (sorted) location within the gene list.
            Normally neuron genes can safely be assumed to have a new Innovation ID higher
            than all existing IDs, and so we can just call Add().
            This routine handles genes with older IDs that need placing correctly.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeuronGeneList.Remove(System.UInt32)">
            <summary>
            Remove the neuron gene with the specified innovation ID.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeuronGeneList.GetNeuronById(System.UInt32)">
            <summary>
            Gets the neuron gene with the specified innovation ID using a fast binary search. 
            Returns null if no such gene is in the list.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeuronGeneList.SortByInnovationId">
            <summary>
            Sort neuron gene's into ascending order by their innovation IDs.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeuronGeneList.BinarySearch(System.UInt32)">
            <summary>
            Obtain the index of the gene with the specified ID by performing a binary search.
            Binary search is fast and can be performed so long as the genes are sorted by ID.
            If the genes are not sorted then the behaviour of this method is undefined.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeuronGeneList.IsSorted">
            <summary>
            For debug purposes only. Don't call this method in normal circumstances as it is an
            expensive O(n) operation.
            </summary>
        </member>
        <member name="T:SharpNeat.Genomes.Neat.NeuronGene">
            <summary>
            A gene that represents a single neuron in NEAT.
            </summary>
        </member>
        <member name="F:SharpNeat.Genomes.Neat.NeuronGene._innovationId">
            <summary>
            Although this ID is allocated from the global innovation ID pool, neurons do not participate 
            in compatibility measurements and so it is not actually used as an innovation ID. 
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeuronGene.#ctor(SharpNeat.Genomes.Neat.NeuronGene)">
            <summary>
            Copy constructor.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeuronGene.#ctor(System.UInt32,SharpNeat.Network.NodeType,System.Int32)">
            <summary>
            Construct new NeuronGene with the specified innovationId, neuron type 
            and activation function ID.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeuronGene.CreateCopy">
            <summary>
            Creates a copy of the current gene. Virtual method that can be overriden by sub-types.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeuronGene.InnovationId">
            <summary>
            Gets the neuron's innovation ID.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeuronGene.NodeType">
            <summary>
            Gets the neuron's type.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeuronGene.ActivationFnId">
            <summary>
            Gets the neuron's activation function ID. 
            For NEAT this is not used and will always be zero.
            For CPPNs/HyperNEAT this ID corresponds to an entry in the IActivationFunctionLibrary
            present in the current genome2 factory.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeuronGene.Id">
            <summary>
            Gets the network node's ID.
            </summary>
        </member>
        <member name="T:SharpNeat.Genomes.Neat.NeatGenomeStats">
            <summary>
            Various statistics for NeatGenome.
            </summary>
        </member>
        <member name="F:SharpNeat.Genomes.Neat.NeatGenomeStats._mutationCountConnectionWeights">
            <summary>
            Total number of connection weight mutation operations. This is the number of calls to the
            mutatation routine, not the total number of weights mutated (there are typically multiple
            weights mutated on a genome2 at a time).
            </summary>
        </member>
        <member name="F:SharpNeat.Genomes.Neat.NeatGenomeStats._mutationCountAddNode">
            <summary>
            Total number of 'add node' mutations.
            </summary>
        </member>
        <member name="F:SharpNeat.Genomes.Neat.NeatGenomeStats._mutationCountAddConnection">
            <summary>
            Total number of 'add connection' mutations.
            </summary>
        </member>
        <member name="F:SharpNeat.Genomes.Neat.NeatGenomeStats._mutationCountDeleteConnection">
            <summary>
            Total number of 'delete connection' mutations.
            </summary>
        </member>
        <member name="F:SharpNeat.Genomes.Neat.NeatGenomeStats._mutationCountDeleteSimpleNeuron">
            <summary>
            Total number of 'delete simple neuron' mutations.
            </summary>
        </member>
        <member name="T:SharpNeat.EvolutionAlgorithms.ComplexityRegulation.ComplexityRegulationMode">
             <summary>
             Complexity regulation modes.
             
             Represents two variations in the overall search strategy - complexifying and simplifying.
             That is, allowing genomes to complexify and reducing their complexity to trim away excess 
             and/or redundant structure in the population to reinvigorate a search.
            
             For more information see:
             Phased Searching with NEAT: Alternating Between Complexification And Simplification, Colin Green, 2004
             (http://sharpneat.sourceforge.net/phasedsearch.html)
             </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithms.ComplexityRegulation.ComplexityRegulationMode.Complexifying">
            <summary>
            Search by allowing genomes to complexify (add new structure).
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithms.ComplexityRegulation.ComplexityRegulationMode.Simplifying">
            <summary>
            Search by simplifying genomes (removing structure).
            </summary>
        </member>
        <member name="T:SharpNeat.Core.Specie`1">
            <summary>
            Represents a single specie within a speciated population.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.Specie`1.#ctor(System.UInt32,System.Int32)">
            <summary>
            Construct a specie with the specified ID and index in its parent list/array.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.Specie`1.#ctor(System.UInt32,System.Int32,System.Int32)">
            <summary>
            Construct a specie with the specified ID, index; and creates an empty genome2 list with a specified capacity.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.Specie`1.CalcTotalFitness">
            <summary>
            Calculates the total fitness of all genomes within the specie.
            Implemented as a method rather than a property as an indication that this method does significant
            work to calculate the value.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.Specie`1.CalcMeanFitness">
            <summary>
            Calculates the mean fitness of genomes within the specie.
            Implemented as a method rather than a property as an indication that this method does significant
            work to calculate the value.        
            </summary>
        </member>
        <member name="M:SharpNeat.Core.Specie`1.CalcTotalComplexity">
            <summary>
            Calculates the total complexity of all genomes within the specie.
            Implemented as a method rather than a property as an indication that this method does significant
            work to calculate the value.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.Specie`1.CalcMeanComplexity">
            <summary>
            Calculates the mean complexity of genomes within the specie.
            Implemented as a method rather than a property as an indication that this method does significant
            work to calculate the value.        
            </summary>
        </member>
        <member name="P:SharpNeat.Core.Specie`1.Id">
            <summary>
            Gets the specie's ID. Specie IDs are unique within a population.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.Specie`1.Idx">
            <summary>
            Gets or sets the index of the specie in its containing list. This is a working variable
            that typically will be the same as the specie ID but is not guaranteed to be e.g. in a distributed NEAT 
            environment where specie IDs may become non-contiguous.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.Specie`1.GenomeList">
            <summary>
            Gets the list of all genomes in the specie.
            </summary>
        </member>
        <member name="P:SharpNeat.Core.Specie`1.Centroid">
            <summary>
            Gets or sets the centroid position for all genomes within the specie. Note that this may be out of 
            date, it is the responsibility of code external to this class to recalculate and set a new centroid
            if the set of genomes in the specie has changed and therefore the specieList centroid has also changed.
            </summary>
        </member>
        <member name="T:SharpNeat.SpeciationStrategies.SpeciationUtils">
            <summary>
            Static helper methods for speciation.
            </summary>
        </member>
        <member name="M:SharpNeat.SpeciationStrategies.SpeciationUtils.TestEmptySpecies``1(System.Collections.Generic.IList{SharpNeat.Core.Specie{``0}})">
            <summary>
            Returns true if all of the species are empty.
            </summary>
        </member>
        <member name="M:SharpNeat.SpeciationStrategies.SpeciationUtils.TestPopulatedSpecies``1(System.Collections.Generic.IList{SharpNeat.Core.Specie{``0}})">
            <summary>
            Returns true if all species contain at least 1 genome2.
            </summary>
        </member>
        <member name="T:SharpNeat.EvolutionAlgorithms.ComplexityRegulation.ComplexityCeilingType">
            <summary>
            Complexity ceiling types.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithms.ComplexityRegulation.ComplexityCeilingType.Absolute">
            <summary>
            Defines an absolute ceiling on complexity.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithms.ComplexityRegulation.ComplexityCeilingType.Relative">
            <summary>
            Defines a relative ceiling on complexity. E.g. relative to the complexity
            at the end of the most recent simplification phase.
            </summary>
        </member>
        <member name="T:SharpNeat.Phenomes.SignalArray">
            <summary>
            SignalArray wraps a native array along with an offset into that array. The resulting SignalArray
            provides offset indexed access to the underlying native array.
            
            SignalArray minimizes the amount of value copying required when setting input signal values to, and
            reading output values from an IBlackBox. E.g. FastRecurrentNetwork requires all input, output and 
            hidden node activation values to be stored in a single array. This class allows us to handle direct 
            access to the input and output values through their own SignalArray, thus we can set individual values
            in the underlying native array directly without having knowledge of that array's structure. An alternative
            would be to pass arrays to SetInputs() and SetOutput() methods, requiring us to copy the complete contents
            of the arrays into the IBlackBox's working array on each call.
            
            This class is effectively a substitute for array pointer manipulation as is possible in C++, e.g. in
            C++ you might do something like:
            <code>
            double[] allSignals = new double[100];
            double[] inputSignals = &amp;allSignals + 1;    // Skip bias neuron.
            double[] outputSignals = &amp;allSignals + 10;  // Skip bias and input neurons.
            </code>
            In the above example access to the real items outside of the bounds of the sub-ranges is
            possible (e.g. inputSignals[10] yields the first output signal). SignalArray also does not check for
            such out-of-bounds accesses, accept when running with a debugger attached in which case assertions will
            make these tests.
            </summary>
        </member>
        <member name="T:SharpNeat.Phenomes.ISignalArray">
            <summary>
            An abstraction of the SignalArray class. Provided to allow custom implementations of a signal array
            if required.
            </summary>
        </member>
        <member name="M:SharpNeat.Phenomes.ISignalArray.CopyTo(System.Double[],System.Int32)">
            <summary>
            Copies all elements from the current SignalArray to the specified target array starting 
            at the specified target Array index. 
            </summary>
            <param name="targetArray">The array to copy elements to.</param>
            <param name="targetIndex">The targetArray index at which copying to begins.</param>
        </member>
        <member name="M:SharpNeat.Phenomes.ISignalArray.CopyTo(System.Double[],System.Int32,System.Int32)">
            <summary>
            Copies <paramref name="length"/> elements from the current SignalArray to the specified target
            array starting at the specified target Array index. 
            </summary>
            <param name="targetArray">The array to copy elements to.</param>
            <param name="targetIndex">The targetArray index at which storing begins.</param>
            <param name="length">The number of elements to copy.</param>
        </member>
        <member name="M:SharpNeat.Phenomes.ISignalArray.CopyTo(System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Copies <paramref name="length"/> elements from the current SignalArray to the specified target
            starting from <paramref name="targetIndex"/> on the target array and <paramref name="sourceIndex"/>
            on the current source SignalArray.
            </summary>
            <param name="targetArray">The array to copy elements to.</param>
            <param name="targetIndex">The targetArray index at which copying begins.</param>
            <param name="sourceIndex">The index into the current SignalArray at which copying begins.</param>
            <param name="length">The number of elements to copy.</param>
        </member>
        <member name="M:SharpNeat.Phenomes.ISignalArray.CopyFrom(System.Double[],System.Int32)">
            <summary>
            Copies all elements from the source array writing them into the current SignalArray starting
            at the specified targetIndex.
            </summary>
            <param name="sourceArray">The array to copy elements from.</param>
            <param name="targetIndex">The index into the current SignalArray at which copying begins.</param>
        </member>
        <member name="M:SharpNeat.Phenomes.ISignalArray.CopyFrom(System.Double[],System.Int32,System.Int32)">
            <summary>
            Copies <paramref name="length"/> elements from the source array writing them to the current SignalArray 
            starting at the specified targetIndex.
            </summary>
            <param name="sourceArray">The array to copy elements from.</param>
            <param name="targetIndex">The index into the current SignalArray at which copying begins.</param>
            <param name="length">The number of elements to copy.</param>
        </member>
        <member name="M:SharpNeat.Phenomes.ISignalArray.CopyFrom(System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Copies <paramref name="length"/> elements starting from sourceIndex on sourceArray to the current
            SignalArray starting at the specified targetIndex.
            </summary>
            <param name="sourceArray">The array to copy elements from.</param>
            <param name="sourceIndex">The sourceArray index at which copying begins.</param>
            <param name="targetIndex">The index into the current SignalArray at which copying begins.</param>
            <param name="length">The number of elements to copy.</param>
        </member>
        <member name="M:SharpNeat.Phenomes.ISignalArray.Reset">
            <summary>
            Reset all array elements to zero.
            </summary>
        </member>
        <member name="P:SharpNeat.Phenomes.ISignalArray.Item(System.Int32)">
            <summary>
            Gets or sets the signal value at the specified index.
            </summary>
        </member>
        <member name="P:SharpNeat.Phenomes.ISignalArray.Length">
            <summary>
            Gets the length of the signal array.
            </summary>
        </member>
        <member name="M:SharpNeat.Phenomes.SignalArray.#ctor(System.Double[],System.Int32,System.Int32)">
            <summary>
            Construct a SignalArray that wraps the provided wrappedArray.
            </summary>
        </member>
        <member name="M:SharpNeat.Phenomes.SignalArray.CopyTo(System.Double[],System.Int32)">
            <summary>
            Copies all elements from the current SignalArray to the specified target array starting 
            at the specified target Array index. 
            </summary>
            <param name="targetArray">The array to copy elements to.</param>
            <param name="targetIndex">The targetArray index at which copying to begins.</param>
        </member>
        <member name="M:SharpNeat.Phenomes.SignalArray.CopyTo(System.Double[],System.Int32,System.Int32)">
            <summary>
            Copies <paramref name="length"/> elements from the current SignalArray to the specified target
            array starting at the specified target Array index. 
            </summary>
            <param name="targetArray">The array to copy elements to.</param>
            <param name="targetIndex">The targetArray index at which storing begins.</param>
            <param name="length">The number of elements to copy.</param>
        </member>
        <member name="M:SharpNeat.Phenomes.SignalArray.CopyTo(System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Copies <paramref name="length"/> elements from the current SignalArray to the specified target
            starting from <paramref name="targetIndex"/> on the target array and <paramref name="sourceIndex"/>
            on the current source SignalArray.
            </summary>
            <param name="targetArray">The array to copy elements to.</param>
            <param name="targetIndex">The targetArray index at which copying begins.</param>
            <param name="sourceIndex">The index into the current SignalArray at which copying begins.</param>
            <param name="length">The number of elements to copy.</param>
        </member>
        <member name="M:SharpNeat.Phenomes.SignalArray.CopyFrom(System.Double[],System.Int32)">
            <summary>
            Copies all elements from the source array writing them into the current SignalArray starting
            at the specified targetIndex.
            </summary>
            <param name="sourceArray">The array to copy elements from.</param>
            <param name="targetIndex">The index into the current SignalArray at which copying begins.</param>
        </member>
        <member name="M:SharpNeat.Phenomes.SignalArray.CopyFrom(System.Double[],System.Int32,System.Int32)">
            <summary>
            Copies <paramref name="length"/> elements from the source array writing them to the current SignalArray 
            starting at the specified targetIndex.
            </summary>
            <param name="sourceArray">The array to copy elements from.</param>
            <param name="targetIndex">The index into the current SignalArray at which copying begins.</param>
            <param name="length">The number of elements to copy.</param>
        </member>
        <member name="M:SharpNeat.Phenomes.SignalArray.CopyFrom(System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Copies <paramref name="length"/> elements starting from sourceIndex on sourceArray to the current
            SignalArray starting at the specified targetIndex.
            </summary>
            <param name="sourceArray">The array to copy elements from.</param>
            <param name="sourceIndex">The sourceArray index at which copying begins.</param>
            <param name="targetIndex">The index into the current SignalArray at which copying begins.</param>
            <param name="length">The number of elements to copy.</param>
        </member>
        <member name="M:SharpNeat.Phenomes.SignalArray.Reset">
            <summary>
            Reset all array elements to zero.
            </summary>
        </member>
        <member name="P:SharpNeat.Phenomes.SignalArray.Item(System.Int32)">
            <summary>
            Gets or sets the single value at the specified index.
            
            We assert that the index is within the defined range of the signal array. Throwing
            an exception would be more correct but the check would affect performance of problem
            domains with large I/O throughput.
            </summary>
        </member>
        <member name="P:SharpNeat.Phenomes.SignalArray.Length">
            <summary>
            Gets the length of the signal array.
            </summary>
        </member>
        <member name="T:SharpNeat.Genomes.Neat.NeatGenome">
            <summary>
            A genome2 class for Neuro Evolution of Augemting Topologies (NEAT).
            
            Note that neuron genes must be arranged according to the following layout plan.
                 Bias - single neuron. Innovation ID = 0
                 Input neurons.
                 Output neurons.
                 Hidden neurons.
            
            This allows us to add and remove hidden neurons without affecting the position of the bias,
            input and output neurons; This is convenient because bias and input and output neurons are
            fixed, they cannot be added to or removed and so remain constant throughout a given run. In fact they
            are only stored in the same list as hidden nodes as an efficiency measure when producing offspring 
            and decoding genomes, otherwise it would probably make sense to store them in readonly lists.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenome.#ctor(SharpNeat.Genomes.Neat.NeatGenomeFactory,System.UInt32,System.UInt32,SharpNeat.Genomes.Neat.NeuronGeneList,SharpNeat.Genomes.Neat.ConnectionGeneList,System.Int32,System.Int32)">
            <summary>
            Constructs with the provided ID, birth generation and gene lists.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenome.#ctor(SharpNeat.Genomes.Neat.NeatGenome,System.UInt32,System.UInt32)">
            <summary>
            Copy constructor.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenome.CreateOffspring(System.UInt32)">
            <summary>
            Asexual reproduction.
            </summary>
            <param name="birthGeneration">The current evolution algorithm generation. 
            Assigned to the new genome2 at its birth generation.</param>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenome.CreateOffspring(SharpNeat.Genomes.Neat.NeatGenome,System.UInt32)">
            <summary>
            Sexual reproduction.
            </summary>
            <param name="parent">The other parent genome2 (mates with the current genome2).</param>
            <param name="birthGeneration">The current evolution algorithm generation. 
            Assigned to the new genome2 at its birth generation.</param>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenome.Mutate_AddNode">
            <summary>
            Add a new node to the Genome. We do this by removing a connection at random and inserting a new
            node and two new connections that make the same circuit as the original connection, that is, we split an 
            existing connection. This way the new node is integrated into the network from the outset.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenome.Mutate_AddNode_GetIDs(System.UInt32,SharpNeat.Genomes.Neat.AddedNeuronGeneStruct@)">
            <summary>
            Gets innovation IDs for a new neuron and two connections. We add neurons by splitting an existing connection, here we
            check if the connection to be split has previously been split and if so attemopt to re-use the IDs assigned during that
            split.
            </summary>
            <param name="connectionToReplaceId">ID of the connection that is being replaced.</param>
            <param name="idStruct">Conveys the required IDs back to the caller.</param>
            <returns>Returns true if the IDs are existing IDs from a matching structure in the history buffer (AddedNeuronBuffer).</returns>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenome.Mutate_DeleteSimpleNeuronStructure">
            <summary>
            We define a simple neuron structure as a neuron that has a single incoming connection and one or more 
            outgoing connections, or one or more incoming connections and one outgoing connection.
            We can easily eliminate such a neuron and maintauin connectivity between remainign neurons by changing 
            the common endpoint of the multiple connections to that of the single connection's.
            If the neuron's non-linearity was not being used then such a mutation is a simplification of the network
            structure that may not adversly affect its functionality despite having one less neuron.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenome.Mutate_ConnectionWeights_GetMutateWeightMethod(SharpNeat.Genomes.Neat.ConnectionMutationInfo)">
            <summary>
            Method that returns a delegate to perform connection weight mutation based on the provided ConnectionMutationInfo
            object. Re-using such a delegate obviates the need to test the type of mutation on each weight mutation operation, thus
            eliminating many branch execution operations.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenome.TestForExistingConnection(System.UInt32,System.UInt32)">
            <summary>
            Tests for an existing connection between a source and target neuron specified by innovation ID.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenome.IsNeuronRedundant(System.Int32)">
            <summary>
            Redundant neurons are hidden neurons with no connections attached to them.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenome.BuildHiddenNeuronConnectionsLookupDictionary">
            <summary>
            Builds a dictionary for temporary use required by Mutate_DeleteSimpleNeuronStructure() and 
            RemoveSimpleNeuron().
            
            The dictionary keys all hidden neurons by their ID. The keyed value is a NeuronConnectionsLookup
            object which lists all of the neuron's incoming and outgoing connections in two separate lists.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenome.CreateOffspring_Sexual_AddGene(SharpNeat.Genomes.Neat.ConnectionGeneListBuilder,SharpNeat.Genomes.Neat.ConnectionGene,System.Boolean)">
            <summary>
            Register/add a connection gene to the provided ConnectionGeneListBuilder. This is a list that will be used to 
            instantiate a new genome2. New additions are registered with a dictionary of ConnectionGenes keyed
            on ConnectionEndpointsStruct so that we can avoid adding connection genes with the same neuron endpoints,
            this is possible because the innovation history buffers throw away old innovations in a FIFO manner in 
            order to prevent them from growing in size indefinitely.
            
            A dictionary of neuron IDs keeps track of all neuron IDs encountered on connection endpoints. We use this
            as the source of unique neuron IDs when creating neuron genes for the new genome2. We use a SortedDictionary
            because it has O(log n) insertion time for unsorted data versus the SortedList's O(n).
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenome.CorrelateConnectionGeneLists(SharpNeat.Genomes.Neat.ConnectionGeneList,SharpNeat.Genomes.Neat.ConnectionGeneList)">
            <summary>
            Correlates the ConnectionGenes from two distinct genomes based upon gene innovation numbers.
            </summary>
        </member>
        <member name="M:SharpNeat.Genomes.Neat.NeatGenome.PerformIntegrityCheck">
            <summary>
            Performs an integrity check on the genome2's internal data.
            Returns true if OK.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenome.Id">
            <summary>
            Gets the genome2's unique ID. IDs are unique across all genomes created from a single 
            IGenomeFactory and all ancestor genomes spawned from those genomes.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenome.SpecieIdx">
            <summary>
            Gets or sets a specie index. This is the index of the species that the genome2 is in.
            Implementing this is required only when using evolution algorithms that speciate genomes.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenome.BirthGeneration">
            <summary>
            Gets the generation that this genome2 was born/created in. Used to track genome2 age.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenome.EvaluationInfo">
            <summary>
            Gets evaluation information for the genome2, including its fitness.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenome.Complexity">
            <summary>
            Gets a value that indicates the magnitude of a genome2's complexity. 
            For a NeatGenome we return the number of connection genes since a neural network's
            complexity is approximately proportional to the number of connections - the number of
            neurons is less important and can be viewed as being a limit on the possible number of
            connections.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenome.Position">
            <summary>
            Gets a coordinate that represents the genome2's position in the search space (also known
            as the genetic encoding space). This allows speciation/clustering algorithms to operate on
            an abstract cordinate data type rather than being coded against specific IGenome types.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenome.CachedPhenome">
            <summary>
            Gets or sets a cached phenome obtained from decodign the genome2.
            Genomes are typically decoded to Phenomes for evaluation. This property allows decoders to 
            cache the phenome in order to avoid decoding on each re-evaluation; However, this is optional.
            The phenome in un-typed to prevent the class framework from becoming overly complex.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenome.GenomeFactory">
            <summary>
            Gets or sets the NeatGenomeFactory associated with the genome2. A reference to the factory is 
            passed to spawned genomes, this allows all genomes within a population to have access to common 
            data such as NeatGenomeParameters and an ID generator.
            Setting the genome2 factory after construction is allowed in order to resolve chicken-and-egg
            scenarios when loading genomes from storage.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenome.NeuronGeneList">
            <summary>
            Gets the genome2's list of neuron genes.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenome.ConnectionGeneList">
            <summary>
            Gets the genome2's list of connection genes.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenome.InputNeuronCount">
            <summary>
            Gets the number of input neurons represented by the genome2.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenome.InputAndBiasNeuronCount">
            <summary>
            Gets the number of input and bias neurons represented by the genome2.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenome.OutputNeuronCount">
            <summary>
            Gets the number of output neurons represented by the genome2.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenome.InputBiasOutputNeuronCount">
            <summary>
            Gets the number total number of neurons represented by the genome2.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenome.InputNodeCount">
            <summary>
            Gets the number of input nodes. This does not include the bias node which is always present.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenome.OutputNodeCount">
            <summary>
            Gets the number of output nodes.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenome.ActivationFnLibrary">
            <summary>
            Gets the network's activation function library. The activation function at each node is 
            represented by an integer ID, which refers to a function in this activation function library.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenome.NodeList">
            <summary>
            Gets the list of network nodes.
            </summary>
        </member>
        <member name="P:SharpNeat.Genomes.Neat.NeatGenome.ConnectionList">
            <summary>
            Gets the list of network connections.
            </summary>
        </member>
        <member name="T:SharpNeat.EvolutionAlgorithms.NeatAlgorithmStats">
            <summary>
            Neat evolution algorithm statistics.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithms.NeatAlgorithmStats._generation">
            <summary>
            The current generation number.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithms.NeatAlgorithmStats._totalEvaluationCount">
            <summary>
            The total number of genome2 evaluations for the current NEAT search.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithms.NeatAlgorithmStats._evaluationsPerSec">
            <summary>
            Current evaluations per second reading.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithms.NeatAlgorithmStats._evalsPerSecLastSampleTime">
            <summary>
            The clock time of the last update to _evaluationsPerSec.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithms.NeatAlgorithmStats._evalsCountAtLastUpdate">
            <summary>
            The total evaluation count at the last update to _evaluationsPerSec.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithms.NeatAlgorithmStats._maxFitness">
            <summary>
            The fitness of the best genome2.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithms.NeatAlgorithmStats._meanFitness">
            <summary>
            The mean genome2 fitness.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithms.NeatAlgorithmStats._meanSpecieChampFitness">
            <summary>
            The mean fitness of current specie champions.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithms.NeatAlgorithmStats._maxComplexity">
            <summary>
            The complexity of the most complex genome2.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithms.NeatAlgorithmStats._meanComplexity">
            <summary>
            The mean genome2 complexity.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithms.NeatAlgorithmStats._totalOffspringCount">
            <summary>
            Total number of offspring created in the lifetime of a NEAT search.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithms.NeatAlgorithmStats._asexualOffspringCount">
            <summary>
            Total number of genomes created from asexual reproduction.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithms.NeatAlgorithmStats._sexualOffspringCount">
            <summary>
            Total number of genomes created from sexual reproduction. This includes
            the number of offspring created from interspecies reproduction.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithms.NeatAlgorithmStats._interspeciesOffspringCount">
            <summary>
            Total number of genomes created from interspecies sexual reproduction.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithms.NeatAlgorithmStats._minSpecieSize">
            <summary>
            The number of genomes in the smallest specie.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithms.NeatAlgorithmStats._maxSpecieSize">
            <summary>
            The number of genomes in the largest specie.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithms.NeatAlgorithmStats._bestFitnessMA">
            <summary>
            A buffer of the N most recent best fitness values. Allows the calculation of a moving average.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithms.NeatAlgorithmStats._meanSpecieChampFitnessMA">
            <summary>
            A buffer of the N most recent mean specie champ fitness values (the average fitness of all specie champs).
            Allows the calculation of a moving average.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithms.NeatAlgorithmStats._complexityMA">
            <summary>
            A buffer of the N most recent population mean complexity values.
            Allows the calculation of a moving average.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithms.NeatAlgorithmStats._prevBestFitnessMA">
            <summary>
            The previous moving average value for the 'best fitness' series. Allows testing for fitness stalling by comparing
            with the current MA value.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithms.NeatAlgorithmStats._prevMeanSpecieChampFitnessMA">
            <summary>
            The previous moving average value for the 'mean specie champ fitness' series. Allows testing for fitness stalling
            by comparing with the current MA value.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithms.NeatAlgorithmStats._prevComplexityMA">
            <summary>
            The previous moving average value for the complexity series. Allows testing for stalling during the simplification 
            phase of complexity regulation.
            </summary>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithms.NeatAlgorithmStats.#ctor(SharpNeat.EvolutionAlgorithms.NeatEvolutionAlgorithmParameters)">
            <summary>
            Construct a NEAT statistics object based on a specified set of NEAT parameters.
            </summary>
        </member>
        <member name="T:SharpNeat.EvolutionAlgorithms.ComplexityRegulation.DefaultComplexityRegulationStrategy">
            <summary>
            Default complexity regulation strategy. 
            This strategy provides a choice of hard/absolute comelity ceiling or a ceiling relative to the 
            complexity at the end of the most recent simplification phase.
            The strategy transitions from complexifying to simplifying when the ceiling is reached. 
            Transitioning from simplifying to complexifying occurs when complexity is no longer falling
            *and* complexity is below the ceiling. This is determined by tracking a complexity moving average
            calculated over the past N generations.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithms.ComplexityRegulation.DefaultComplexityRegulationStrategy.MinSimplifcationGenerations">
            <summary>
            The minimum number of generations we stay within simplifcation mode.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithms.ComplexityRegulation.DefaultComplexityRegulationStrategy._ceilingType">
            <summary>
            The ceiling type - absolute or relative.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithms.ComplexityRegulation.DefaultComplexityRegulationStrategy._complexityCeiling">
            <summary>
            The ceiling value passed into the constructor. Allows the true ceiling to be calculated
            if the ceiling type is relative.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithms.ComplexityRegulation.DefaultComplexityRegulationStrategy._complexityCeilingCurrent">
            <summary>
            The ceiling point at which we switch to 'simplifying' mode. This value may be fixed 
            (absolute ceiling) or may be relative to some other value, e.g. the complexity at the
            end of the last simplification phase.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithms.ComplexityRegulation.DefaultComplexityRegulationStrategy._currentMode">
            <summary>
            The current regulation mode - simplifying or complexifying.
            </summary>
        </member>
        <member name="F:SharpNeat.EvolutionAlgorithms.ComplexityRegulation.DefaultComplexityRegulationStrategy._lastTransitionGeneration">
            <summary>
            The generation at which the last transition occured.
            </summary>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithms.ComplexityRegulation.DefaultComplexityRegulationStrategy.#ctor(SharpNeat.EvolutionAlgorithms.ComplexityRegulation.ComplexityCeilingType,System.Double)">
            <summary>
            Construct the complexity regulation strategy with the provided regulation parameters.
            </summary>
        </member>
        <member name="M:SharpNeat.EvolutionAlgorithms.ComplexityRegulation.DefaultComplexityRegulationStrategy.DetermineMode(SharpNeat.EvolutionAlgorithms.NeatAlgorithmStats)">
            <summary>
            Determine which complexity regulation mode the search should be in given the provided
            NEAT algorithm stats.
            </summary>
        </member>
        <member name="T:SharpNeat.Core.GenomeFitnessComparer`1">
            <summary>
            Sort genomes, highest fitness first. Genomes with equal fitness are secondary sorted by age 
            (youngest first). Used by the selection routines to select the fittest and youngest genomes.
            </summary>
        </member>
        <member name="F:SharpNeat.Core.GenomeFitnessComparer`1.Singleton">
            <summary>
            Pre-built comparer.
            </summary>
        </member>
        <member name="M:SharpNeat.Core.GenomeFitnessComparer`1.Compare(`0,`0)">
            <summary>
            Sort genomes, highest fitness first. Genomes with equal fitness are secondary sorted by age (youngest first).
            Used by the selection routines to select the fittest and youngest genomes.
            </summary>
        </member>
    </members>
</doc>
